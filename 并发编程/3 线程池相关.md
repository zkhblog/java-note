# 原理

# 线程池执行过程中遇到异常
① 任务抛出了异常，如果线程池中的任务抛出了异常，那么这个线程就会中止运行，通常情况下，可以通过 try-catch 块捕获异常，
在 catch 块中记录错误信息，并对其进行处理。另外，建议在拒绝策略中记录相应的日志信息，以便调试和排查问题。  
② 线程池执行器抛出了异常 如果线程池执行器（Executor）抛出了异常，那么这个线程池的所有线程都会中止运行。
此时需要查找问题并进行修复，然后重新创建一个新的线程池。  
③ 拒绝策略无法处理任务 当任务过多时，线程池内部的工作队列可能会满载，此时就需要采用相应的拒绝策略。
常见 的拒绝策略包括：CallerRunsPolicy、AbortPolicy、DiscardPolicy 和 DiscardOldestPolicy 等。在任何情况下，
拒绝策略应该能够处理掉未能执行的任务，否则可能导致系统崩溃或数据一致性问题等，因此建议使用带日志记录和异常处理的自定义拒绝策略。

# 如何处理线程池遇到的异常
1 try-catch块捕获异常，在线程池中启动时，通常会使用ExecutorService的execute()方法提交任务，如果该任务产生异常，则可以使用try-catch
块来捕获这些异常，从而记录异常信息并对其进行特殊处理
```
ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10,
        60L, TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(1000),
        r -> {
            Thread t = new Thread(r);
            t.setDaemon(true);
            return t;
        });

executor.execute(() -> {
    try {
        // do something
    } catch (Exception e) {
        logger.error("execute task failed", e);
    }
});
```
2 自定义拒绝策略 线程池的拒绝策略是一项非常重要的配置，它主要用于处理那些无法提交到队列中的任务  
自定义拒绝策略时，需要注意以下几点：  
2.1 保证原子性：应该确保该操作是原子性的，也就是两个线程不会同时执行这个操作  
2.2 避免死锁：要避免因为线程等待而引起的死锁问题  
2.3 避免内存泄漏：要确保除了正常失败的任务之外，其他任务可以得到清理和回收  
```
// 自定义拒绝策略CustomRejectedExecutionHandler，当线程池的工作队列已满并且无法继续添加新任务时，ExecutorService 会调用这个拒绝策略进行处理
// 当线程池的工作队列已满时，我们使用 while 循环来等待队列有空余位置，从而避免任务执行失败
public class CustomRejectedExecutionHandler implements RejectedExecutionHandler {
 
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        try {
            // 阻塞等待队列空闲
            while (!executor.getQueue().offer(r, 1, TimeUnit.SECONDS)) {
                System.out.println("inner offer over");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```
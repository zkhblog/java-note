### redis常见问题
解决缓存穿透问题：可以缓存null结果  
解决缓存雪崩问题：在设置过期时间时，加随机值  
解决缓存击穿问题：加锁

### redis做分布式锁的问题
① 加锁保证原子性  
```set key value EX NX```  

② 解锁保证原子性  
使用redisTemplate + lua脚本实现  

③ 锁的续期问题  
最简单的处理方式是增加锁的过期时间，但是这不实用  

### redisson
① 默认过期时间30s，如果业务超长，运行期间自动续期，不用担心因为业务时间长，锁自动过期被删掉  

② 看门狗时间  
```lock.lock();```  
```lock.lock(10, TimeUnit.SECONDS);```  
指定过期时间时，在锁的时间到了之后，不会自动续期。因为发送给redis的执行脚本，在进行占锁时，默认超时时间就是我们指定的时间  
未指定过期时间时，使用的超时时间是 30 * 1000【LockWatchDogTimeOut```看门狗```的默认时间】。只要占锁成功，就会启动一个定时任务，这个定时任务会重新给锁设置过期时间，新的过期时间
就是```看门狗```的默认时间，实质是每隔10s都会自动续期【LockWatchDogOut / 3】  

最佳实践：指定过期时间，并手动解锁，保证过期时间超过业务执行时间即可  

### 缓存一致性解决方案
① 实时性要求超高的场景，可以直接读取数据库  
② 缓存加上过期时间可以提升系统吞吐量，加上缓存后，为了减少脏数据的问题，可以采用读写锁保证并发读写（写写排队）  
③ 如果是菜单，商品介绍等基础数据，也可以使用canal订阅binlog的方式（最佳解决方案，缺点是增加了系统复杂度）














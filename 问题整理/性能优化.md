# 线程频繁切换

整体线程资源占用均匀，可能是线程频繁切换上下文导致，可以使用vmstat工具观察

```
vmstat 2 // 表示2秒刷新一次
```

各参数含义：

①in，中断数，包括时钟中断

②cs，每秒上下文切换次数

③us，用户进程消耗cpu时间

④sy，系统进程消耗cpu时间

⑤id，cpu空闲时间

# 线程池的坑

使用完线程池一定记得回收，否则跑着跑着就会内存溢出等问题。

# nacos至少三个节点而不是两个节点

①高可用性：Nacos的节点是通过选举形成主从关系的，其中一个节点为主节点，其余节点为从节点。`当主节点故障时，从节点可以选举出新的主节点`，确保服务的持续可用性。**如果只有两个节点，其中一个节点宕机后，就无法进行选举，导致服务不可用** 。

②数据一致性：Nacos使用Raft一致性算法来保证数据的一致性。`Raft算法要求集群中大多数节点的存储状态一致才能提交更新`。**在一个由两个节点组成的集群中，如果一个节点宕机，仅剩下一个节点，就无法保证数据一致性**。

故障恢复：在一个由三个节点组成的集群中，`当一个节点出现故障时，剩余的两个节点可以与新加入的节点保持一致`，实现快速的故障恢复。**而在一个由两个节点组成的集群中，当一个节点宕机时，整个集群就无法达到大多数节点的一致性要求，无法进行有效的故障恢复**。

# 系统线程数相关

①当```max user processers```设置较小的时候，影响系统线程数目的是```max user processers```的设置

②当```max user processers```设置为65535的时候，影响系统线程数目的是系统的内存

线程数目过多会导致内存溢出。以上对外的异常信息均为```OOM:unable to create native thread```

```
线程数=（进程可用操作系统的最大内存空间-JVM的堆空间-操作系统预留内存）/线程栈大小
```

# 解决方案

```unable to create new native thread``` 这样的错误都有共性，可按照如下方法解决这些问题

①当发现这个错误的时候，第一时间要排查程序是否有bug，是否大量的创建了线程，或者没有正确使用线程池，比如：是否使用了```Executors.newCachedThreadPool()```方法，该方法能创建Integer最大值个线程，创建到一定程度的时候系统资源耗尽就会报错。

②如果发现程序中并没有使用线程却依然报这个错，那么观察一下这个时刻的并发情况如何，要是溢出的这一时刻比其他时候并发量都要大，这时先查看一下系统资源的情况，使用```ulimit -a``` 查看```max user processes```和```open files```这二个属性的值越大，能创建的线程数也就越多。

③如果以上两个属性调大依然报错的话，说明此时受限于系统内存资源了，要是服务器本身内存就比较小的话，建议增加内存。要是服务器内存比较大，就需要通过调整JVM参数来合理分配线程使用的内存，比如减小-Xss值，这个值越小能创建的线程数也就越多，也可以适当减少-Xmx和-Xms的值，增加堆外内存的容量。

# 内存溢出场景

①堆溢出（java.lang.OutOfMemoryError: Java heap space）：最常见最复杂情况

②栈溢出（java.lang.StackOverflowError）：需要关注配置项-Xss的大小

③线程数不够（java.lang.OutOfMemoryError: unable to create new native thread）

④元空间溢出（java.lang.OutOfMemoryError: Metaspace）：需要关注配置项-XX:MaxMetaspaceSize大小。jstat指标参数MC、MU如果发现元空间大小是持续上涨的，则需要检查代码是否存在大量的反射类加载、动态代理生成的类加载等导致。可以通过```-XX:+TraceClassLoading -XX:+TraceClassUnloading```记录下类的加载和卸载情况，反推具体问题代码。

# CPU占用高案例分析

①内存消耗过大，导致full gc次数过多

通过jstack命令可以看到这些线程主要是垃圾回收线程；通过jstat命令监控gc情况，可以看到full gc次数非常多，并且次数在不断增加

②代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢

例如某些复杂算法，甚至算法bug，无限循环递归等等。jstack命令可直接定位到代码行

③由于锁使用不当，导致死锁

死锁不会直接导致cpu资源占用过高，syncronized和aqs中锁的设计是线程获取锁失败时，会主动挂起线程，而不会自旋循环检测锁是否被释放。如果因为死锁，阻塞线程越来越多，内存占用也越来越高且无法释放，导致不停地gc，会造成cpu占用飙升

④线程由于某种原因而进入```TIME_WAITING``` 、```WAITINT```状态

使用synchronized会让等待锁的线程处于Blocked状态

使用AQS相关的锁则会让等待锁的线程处于```TIMED_WAITING```、```WAITING```状态，因为底层基于LockSupport
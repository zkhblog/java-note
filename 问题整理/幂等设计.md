# insert操作时利用唯一索引冲突
加唯一索引：利用唯一索引冲突  
先select一下数据，如果数据已经存在，就拦截是重复请求，直接返回成功，如果数据不存在，再通过主键冲突或者唯一索引冲突做最后保证，即插入数据异常，则可以直接返回成功
> 加唯一索引是个非常简单但很有效的办法，如果重复插入数据的话，就会抛出异常，为了保证幂等性，一般需要捕获这个异常
> 如果是java程序需要捕获：DuplicateKeyException异常，如果使用了spring框架还需要捕获：MySQLIntegrityConstraintViolationException异常。

# Update操作时设置状态方案
有些业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态，可以通过限制状态的流动来完成幂等。

# 建防重表
有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，就可以使用防重表的方式。  
例如消息消费中，创建防重表，存储消息的唯一ID，消费时先去查询是否已经消费，已经消费直接返回成功。

# token令牌机制
![img.png](images/token令牌保证幂等性.png)

### 乐观锁
更新逻辑，也可以用乐观锁，性能更好。可以在表中增加一个timestamp或者version字段，例如version，在更新前，先查询一下数据，将version也作为更新的条件，同时也更新version，
更新成功后，version增加，重复更新请求进来就无法更新了。乐观锁存在ABA的问题，如果version版本一直是自增的就不会出现ABA的情况了
```java
update user set amount=amount+100,version=version+1 where id=123 and version=1;
```

# 分布式锁
直接在数据库上加锁的做法性能不够友好，可以使用分布式锁的方式，目前最流行的分布式锁实现是通过Redis，具体实现一般都是使用Redission框架。
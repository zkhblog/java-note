# 准备工作
在JVM参数中配置以下参数```-XX:+HeapDumpOnOutOfMemoryError```、```-XX:HeapDumpPath```，当内存溢出时输出Dump文件，并指定了dump文件的保存位置  

# 导出dump文件
```shell
jmap -dump:format=b,file=<xxx.hprof> <pid>
```

# 排查过程
① 打开总览页面，看疑似泄露的报告，进入Leak Suspects可以看到，有2处可疑的内存泄露问题，占用了绝大部分的内存  
② 点击Suspect1 details，观察实体类的占用情况（主要是大对象的占用情况），实体类占用越多的越是问题所在，即没被引用但是又不能回收的对象  
③ 通过查看线程栈调用的情况，还可以明确定位该实体类代码位置，便于进一步定位问题产生的根源  

# 内存溢出问题常见原因
① 内存中加载的数据量过于庞大，如一次从数据库中取出过多数据  
② 资源使用之后没有及时关闭，导致对象无法被GC回收  
> 比如批量执行后，资源对象没有及时释放连接，会造成内存占用率过高，而GC在回收这部分内存的时候又没发回收，会造成CPU占用率过高

③ 代码中存在死循环或循环过程中产生过多重复的对象实体  
④ 启动参数内存值设定的过小

# 总结
① 根据排查情况来看，当出现内存溢出时，业务日志基本上无法用于定位问题根源，因为系统崩溃连锁反应会阻塞所有线程和数据库SQL执行，无法从海量的报错里找出引发崩溃的源头  
② 建议先排查GC日志和线程情况，确定内存溢出问题的话，直接拿dump文件分析问题源头，同时复盘最近提交的代码是否存在可疑的内存泄露。
不过根据这次排查发现导致问题的原因并不是最近提交的代码，所以还是建议优先分析dump文件定位泄露源。



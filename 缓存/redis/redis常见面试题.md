# 缓存穿透
指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，
攻击会导致数据库压力过大。
解决：缓存空对象、布隆过滤器、mvc拦截器

# 缓存雪崩
缓存雪崩是指在我们设置缓存时key采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
解决方案：
规避雪崩：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
如果缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中。
设置热点数据永远不过期。
出现雪崩：降级 熔断
事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
事后：利用 redis 持久化机制保存的数据尽快恢复缓存

# 缓存击穿
缓存雪崩和缓存击穿不同的是：
缓存击穿 指 并发查同一条数据。缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

# 内存相关：
如何查看内存大小？
在配置文件中的859行 maxmemory <bytes>  ，注意此处内存大小是bytes字节类型，注意单位转换
还可以通过info maxmemory命令查看redis的内存使用情况
默认情况下的配置：redis的内存大小，如果不进行设置或者设置为0，在64位操作系统下，默认是不限制大小，32位下是3G
一般生产上的配置：一般推荐redis设置内存为最大物理内存的四分之三
既可以通过修改配置文件的大小，又可以通过config set maxmemory 内存大小进行设置
redis过期键的删除策略：
①定时删除：这样对cpu不友好，有一个定时任务时刻在消耗CPU的性能，用处理器性能去换存储空间
②惰性删除：这样对内存不友好，即使很多键已经过期了，由于没有第二次访问，因此不会被删除，
导致内存中有很多的过期键，用存储空间去换处理器性能
③定期删除时前面两种删除策略的折中：
此时依然存在问题：在抽样key时，有key从来没有被抽样到，
所以依然大量过期的key堆积在内存中，导致redis内存空间紧张或者很快耗尽
在所有的方案都有问题后，内存淘汰策略成为了我们的首选方案
内存淘汰策略（八种）
第一种：noeviction：不会驱逐任何key，在新加时会报异常
第二种：allkeys-lru：对所有key使用LRU算法进行删除
第三种：volatile-lru：对所有设置了过期时间的key使用LRU算法进行删除
第四种：allkeys-random：对所有key进行随机删除
第五种：volatile-random：对所有设置了过期时间的key随机删除
第六种：volatile-ttl：删除马上要过期的key
第七种：allkeys-lfu：对所有key使用LFU算法进行删除
第八种：volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除

# 常见面试题
生产上，在配置时一般使用maxmemory-policy allkeys-lru，命令和修改配置文件都可
生产上你们的内存设置多少？
如何配置，修改redis的内存大小？
如果内存满了你怎么办？
redis清理内存的方式？定期删除和惰性删除了解过吗？
redis的缓存淘汰策略？
手写LRU算法？


***
生产上你们的内存设置多少？
如何配置，修改redis的内存大小？
如果内存满了你怎么办？
redis清理内存的方式？定期删除和惰性删除了解过吗？
手写LRU算法？
***

# 缓存穿透
指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，
攻击会导致数据库压力过大。
解决：缓存空对象、布隆过滤器、mvc拦截器

# 缓存雪崩
缓存雪崩是指在我们设置缓存时key采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
解决方案：
规避雪崩：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
如果缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中。
设置热点数据永远不过期。
出现雪崩：降级 熔断
事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
事后：利用 redis 持久化机制保存的数据尽快恢复缓存

# 缓存击穿
缓存雪崩和缓存击穿不同的是：
缓存击穿 指 并发查同一条数据。缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

# redis内存相关
1 如何查看内存大小？在配置文件中的859行 ```maxmemory <bytes>```，注意此处内存大小是bytes字节类型，注意单位转换。  
如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。还可以通过```info maxmemory```命令查看redis的内存使用情况  
一般生产上的配置：一般推荐redis设置内存为最大物理内存的四分之三。既可以通过修改配置文件的大小，也可以通过```config set maxmemory``` 内存大小进行设置  

2 redis过期键的删除策略：  
> redis打满了，会报错  
> (error) OOM command not allowed when used memory > ```maxmemory```

① 定时删除：即检测被设置了生存时间的key，判断是否达到过期时间，达到即删除。这样对cpu不友好，有一个定时任务时刻在消耗CPU的性能，用处理器性能去换存储空间  
② 惰性删除：即下次访问数据时再判断是否到达过期时间，这样对内存不友好，即使很多键已经过期了，但是没有第二次访问（或者执行flushDb可以清除过期key），因此也不会被删除，导致内存中有很多的过期键，用存储空间去换处理器性能  
③ 定期删除：上述两种方案同时使用。这是前面两种删除策略的折中：每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的**时长**和**频率**来减少删除操作对CPU时间的影响。  
此时依然存在问题：在抽样key时，有key从来没有被抽样到，所以依然大量过期的key堆积在内存中，导致redis内存空间紧张或者很快耗尽  

在上述方案执行之后，如果内存达到阈值时，就会触发内存淘汰策略  
生产上，在配置时一般使用```maxmemory-policy allkeys-lru```，命令（```config set maxmemory-policy allkeys-lru```）和修改配置文件都可
> 内存淘汰策略（八种）  
第一种：```noeviction```，不会驱逐任何key，在新加时会报异常（6.0.8默认）  
第二种：```allkeys-lru```，对所有key使用LRU算法进行删除（生产上常用）  
第三种：```volatile-lru```，对所有设置了过期时间的key使用LRU算法进行删除  
第四种：```allkeys-random```，对所有key进行随机删除  
第五种：```volatile-random```，对所有设置了过期时间的key随机删除  
第六种：```volatile-ttl```，删除马上要过期的key  
第七种：```allkeys-lfu```，对所有key使用LFU算法进行删除  
第八种：```volatile-lfu```，对所有设置了过期时间的key使用LFU算法进行删除

# LRU
手写LRU算法？



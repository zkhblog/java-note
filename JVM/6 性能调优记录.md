# 高并发的应用如何优化GC性能
### 问题
高并发查询导致对象快速进入老年代
> 每秒并发量太高，会导致年轻代的Eden区迅速被填满，并且频繁触发Young GC。但是每次触发Young GC时，实际上有很多请求没有处理完毕，就导致有很多对象是需要存活下来  
> 所以问题就是高峰期时，经常出现Young GC过后存活对象较多，在S区存放不下，大量对象因此快速进入老年代，导致老年代频繁触发Full GC

### 解决办法
1 增加机器数量，让每个服务承载更少的并发请求，减轻压力  

2 用jstat分析一下各个机器上的jvm的运行状况，判断出来每次Young GC 后存活对象有多少，然后就是 增加Survivor区的内存，避免对象快速进入 老年代。另外一个，在当时对那个系统优化之后，
增加了年轻代和Survivor区的大 小，但还是会慢慢的有对象进入老年代里，毕竟系统负载很高，彻底让对象不进入老年代也很难做到。所以当时调优过后每小时还是会有一次Full GC。
所以当时 第二个参数的优化就是针对CMS内存碎片问题的在降低了Full GC频率之后，务必设置如下参数```-XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0```，
每次Full GC后都整理一下内存碎 片。否则如果每次Full GC过后，都造成老年代里很多内存碎片，那么必然导致下一次Full GC更快到来，因为内存碎片会导致老年代可用内存变少。
也许第一次Full GC是一小时才有，第二次Full GC也许是40分钟之后，第三次Full GC可能就是20分钟之后，要是不解决CMS内存碎片问题，必然导致Full GC慢慢变得越来越频繁。

# 8G内存通用JVM参数模板

# 元数据区触发Full GC
![img.png](images/Metaspace内存区域占用的波动曲线图.png)
现象分析：  
Metaspace区域的内存呈现一个波动的状态，他总是会先不断增加，达到一个顶点之后，就会把Metaspace区域给占满，然后自然就会触发一次Full GC，Full GC会带着Metaspace区域的垃圾回收，
所以接下来Metaspace区域的内存占用又变得很小了  

问题分析：  
系统在运行过程中，不停的有新的类产生被加载到Metaspace区域里去，然后不停的把Metaspace区域占满，接着触发一次Full GC回收掉Metaspace区域中的部分类  
然后这个过程反复的不断的循环，进而造成Metaspace区域反复被占满，然后反复导致Full GC的发生  

在JVM中加入如下两个参数，追踪类加载和类卸载的情况。加入这两个参数之后，我们就可以看到在Tomcat的catalina.out日志文件中，输出了一堆日志  
```-XX:TraceClassLoading -XX:TraceClassUnloading```  

根本原因：  
JVM运行期间不停的加载这种奇怪的类，然后不停的把Metaspace区域占满，才会触发不停的执行Full GC的。结论就是频繁Full GC不光是老年代触发的，有时候也会因为Metaspace区域的类太多而触发  
在代码里大量用了反射的话，那么JVM就是会动态的去生成一些类放入Metaspace区域里的  
>  在 执行这种反射代码时，JVM会在你反射调用一定次数之后就动态生成一些类，就是我们之前看到的那种莫名其妙的 类。下次你再执行反射的时候，就是直接调用这些类的方法，
> 这是JVM的一个底层优化的机制。  
> 
> 这些class对象是JVM在反射过程中动态生成的的类的class对象，他们都是软引用的，软引用的对象，正常情况下不会回收，但是内存比较紧张的时候就会回收这些对象，具体要不要回收通过公式判断  

之所以会不停的生成奇怪的类，是因为把参数SoftRefLRUPolicyMSPerMB设置成0了，原本的想法是这个参数设置成0后，任何软引用对象就可以尽快释放，其实不然
```

```


核心概述：
①一个JVM实例只存在一个堆内存，堆也是JVM内存管理的核心区域
②Java堆区在JVM启动的时候即被创建，其余空间大小也就确定了，是JVM管理的最大一块内存空间
③《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的
④所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，简称TLAB）
⑤数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
⑥在方法结束后，堆中对象不会马上被移除，仅仅在垃圾收集的时候才被移除
⑦堆，是GC执行垃圾回收的重点区域

堆空间大小的设置：默认情况下，初始内存大小是物理内存的1/64，最大内存大小是物理内存大1/4
Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了
"-Xms"用于表示堆区的起始内存，等价于-XX:InitialHeapSize
"-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize
一旦堆区中的内存大小超过"-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常
通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能
-XX:NewRatio：设置新生代与老年代的比例 。默认是1：2
-XX:-UseAdaptiveSizePolicy：关闭自适应的内存分配策略
-XX:SurvivorRatio：设置新生代中Eden区与Survivor区的比例
-Xmn:设置新生代空间的大小

新生代GC（Minor GC）触发机制：
①当新生代空间不足时，就会触发Minor GC，这里的新生代满指的是Eden满，Survivor满不会引发Minor GC。（每次Minor GC会清理新生代的内存）
②因为Java对象大多具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。
③Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。

老年代GC（Major GC/Full GC）触发机制：
①指发生在老年代的GC，对象从老年代消失时，我们说"Major GC"或"Full GC"发生了
②出现了Major GC，经常会伴随至少一次Minor GC。也就是老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC
③Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长
④如果Major GC后，内存还不足，就报OOM了

Full GC触发机制：
①调用System.gc()时，系统建议执行Full GC，但是不必然执行
②老年代空间不足
③方法区空间不足
④通过Minor GC后进入老年代的平均大小大于老年代的可用内存
⑤由Eden区、s0向s1区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

注意：full gc是开发霍调优中尽量要避免的，这样暂时时间会短暂一些

内存分配策略：
①如果对象在Eden区出生并经过第一次MinorGC后仍然存活，并且能被Survivor区容纳的话，将被移动到Survivor区中，并将对象的年龄设置为1。
对象在Survivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM，每个GC都有所不同）时，
就会被晋升到老年代。
对象晋升老年代的阈值，可以通过选项-XX:MaxTenuringThreshold来设置
②优先分配到Eden区
③大对象直接分配到老年代（尽量避免程序中出现过多的大对象）
④长期存活的对象分配到老年代
⑤动态对象年龄判断
如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代，无需等待
MaxTenuringThreshold中要求的年龄
⑥空间分配担保
-XX:HandlePromotionFailure

测试堆空间常用的JVM参数
①-XX:+PrintFlagsInitial         查看所有的参数的默认值
②-XX:+PrintFlagsFinal           查看所有的参数的最终值（可能会存在修改，不再是初始值）
具体查看某个参数的指令 jps:查看当前运行中的进程
                    jinfo -flag SurvivorRatio 进程id
③-Xms                           初始堆空间内存（默认为物理内存的1/64）
④-Xmx                           最大堆空间内存（默认为物理内存的1/4）
⑤-Xmn                           设置新生代的大小（初始值及最大值）
⑥-XX:NewRatio                   配置新生代与老年代在堆结构的占比
⑦-XX:SurvivorRatio              设置新生代中Eden、S0、S1 空间的比例
⑧-XX:MaxTenuringThreshold       设置新生代垃圾的最大年龄
⑨-XX+PrintGCDetails             输出详细的GC处理日志
打印GC简要信息：-XX:+PrintGC或者-verbose:gc
-XX:HandlePromotionFailure      是否设置空间分配担保


# 堆空间的对象分配优化策略
当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。对于此种情况，则可以采用栈上分配的策略。  
结论：  
①栈上分配。在逃逸分析中，给成员变量赋值、方法有返回值、实例引用传递不能进行栈上分配。开发中能使用局部变量的，就不要使用在方法外定义。  
②同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。  
③分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在
CPU寄存器中。






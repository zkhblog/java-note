# 高并发的应用如何优化GC性能
### 问题
高并发查询导致对象快速进入老年代
> 每秒并发量太高，会导致年轻代的Eden区迅速被填满，并且频繁触发Young GC。但是每次触发Young GC时，实际上有很多请求没有处理完毕，就导致有很多对象是需要存活下来  
> 所以问题就是高峰期时，经常出现Young GC过后存活对象较多，在S区存放不下，大量对象因此快速进入老年代，导致老年代频繁触发Full GC

### 解决办法
1 增加机器数量，让每个服务承载更少的并发请求，减轻压力  

2 用jstat分析一下各个机器上的jvm的运行状况，判断出来每次Young GC 后存活对象有多少，然后就是 增加Survivor区的内存，避免对象快速进入 老年代。另外一个，在当时对那个系统优化之后，
增加了年轻代和Survivor区的大 小，但还是会慢慢的有对象进入老年代里，毕竟系统负载很高，彻底让对象不进入老年代也很难做到。所以当时调优过后每小时还是会有一次Full GC。
所以当时 第二个参数的优化就是针对CMS内存碎片问题的在降低了Full GC频率之后，务必设置如下参数```-XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0```，
每次Full GC后都整理一下内存碎 片。否则如果每次Full GC过后，都造成老年代里很多内存碎片，那么必然导致下一次Full GC更快到来，因为内存碎片会导致老年代可用内存变少。
也许第一次Full GC是一小时才有，第二次Full GC也许是40分钟之后，第三次Full GC可能就是20分钟之后，要是不解决CMS内存碎片问题，必然导致Full GC慢慢变得越来越频繁。

# 8G内存通用JVM参数模板

# 元数据区触发Full GC（不合理的参数设置导致导致频繁触发Full GC）
![img.png](images/Metaspace内存区域占用的波动曲线图.png)
现象分析：  
Metaspace区域的内存呈现一个波动的状态，他总是会先不断增加，达到一个顶点之后，就会把Metaspace区域给占满，然后自然就会触发一次Full GC，Full GC会带着Metaspace区域的垃圾回收，
所以接下来Metaspace区域的内存占用又变得很小了  

问题分析：  
系统在运行过程中，不停的有新的类产生被加载到Metaspace区域里去，然后不停的把Metaspace区域占满，接着触发一次Full GC回收掉Metaspace区域中的部分类  
然后这个过程反复的不断的循环，进而造成Metaspace区域反复被占满，然后反复导致Full GC的发生  

在JVM中加入如下两个参数，追踪类加载和类卸载的情况。加入这两个参数之后，我们就可以看到在Tomcat的catalina.out日志文件中，输出了一堆日志  
```-XX:TraceClassLoading -XX:TraceClassUnloading```  

根本原因：  
JVM运行期间不停的加载这种奇怪的类，然后不停的把Metaspace区域占满，才会触发不停的执行Full GC的。结论就是频繁Full GC不光是老年代触发的，有时候也会因为Metaspace区域的类太多而触发  
在代码里大量用了反射的话，那么JVM就是会动态的去生成一些类放入Metaspace区域里的  
>  在 执行这种反射代码时，JVM会在你反射调用一定次数之后就动态生成一些类，就是我们之前看到的那种莫名其妙的 类。下次你再执行反射的时候，就是直接调用这些类的方法，
> 这是JVM的一个底层优化的机制。  
> 
> 这些class对象是JVM在反射过程中动态生成的的类的class对象，他们都是软引用的，软引用的对象，正常情况下不会回收，但是内存比较紧张的时候就会回收这些对象，具体要不要回收通过公式判断  

```
clock - timestamp <= freespace * SoftRefLRUPolicyMSPerMB
```
之所以会不停的生成奇怪的类，是因为把参数SoftRefLRUPolicyMSPerMB设置成0了，原本的想法是这个参数设置成0后，任何软引用对象就可以尽快释放，其实不然，软引用的对象如果刚创建出来就被一次
Young GC给回收掉，会导致JVM在反射代码的执行过程中，就会继续创建软引用的对象，最终的现象就是这种软引用对象会越来越多，最终就会导致Metaspace区域被放满了，一旦Metaspace区域被占满了，
就会触发Full GC，然后回收掉很多类，接着再次重复上述循环  

问题的解决办法：  
参数```-XX:SoftRefLRUPolicyMSPerMB```不要设置成0，可以设置成几千左右等。提高这个数值，就是让反射过程中JVM自动创建的软引用的一些类的Class对象不要被随便回收，
当时我们优化这个参数之后，就可以看到系统稳定运行了。 基本上Metaspace区域的内存占用是稳定的，不会来回大幅度波动了。  

# 无法释放的内存最终导致OOM
### 现象
内存里的数据必然越来越多，每次Eden区塞满之后，大量存活的对象必须转入老年代中，而且这些老年代里的对象还是无法释放掉的。老年代最终一定会满，而且最终一定会有一次Eden区满之后，
一大批对象要转移到老年代，结果老年代即使Full GC之后还是没有空间可以放的下，最终就会导致内存溢出。然后线上收到报警说内存溢出。最后这个系统全线崩溃，无法正常运行。

### 解决办法
将计算结果写本地磁盘，允许内存中的数据被回收，从而释放大量数据占用的内存

# 内存泄露
不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露

### 软引用的适用场景
假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取则会严重影响性能，但是一次加载到内存中又可能会造成内存溢出  
此种场景，可以用软引用解决这个问题，设计思路是用一个hashMap保存图片路径和与相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的内存空间，从而有效
避免OOM的问题
```java
Map<String,SoftReference<BitMap>> imageCache = new HashMap<String,SoftReference<BitMap>>();
```

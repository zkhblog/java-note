依赖注入有两种方式：
第一种是构造器注入，这是无法解决循环依赖的问题的，在编写代码的时候就会报异常，因为new的对象的参数是需要不停的写下去的。
spring容器会将每一个正在创建的Bean放在一个“当前创建Bean池”中，因此在创建Bean过程中发现自己已经在池中，将抛出
BeanCurrentlyInCreationException异常，对于创建完成的Bean会将其从池中清除。
第二种是setter方法注入，这种方法是可以解决循环依赖问题的，但是如果Bean的作用域是原型模式，即多例的情况下，
会报BeanCurrentlyIncreationException，错误提示是有无法解决的循环依赖问题。
在单例模式下，是可以结局循环依赖问题的，解决的方式是通过三级缓存来解决的
只有单例的Bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的Bean，每次从容器中获取都是一个新的对象，都会重新创建，
所以非单例的Bean是没有缓存的，不会将其放到三级缓存中。
第一级是singletonObjects，存放已经经历了完整声明周期的Bean对象。
第二级缓存是earlySingletonObjects，存放早期暴露出来的Bean对象，Bean的声明周期未结束（属性还未填充完成），是一个半成品对象。
第三级缓存是Map<String,ObejctFactory<?>> singletonFactories，存放可以生产Bean的工厂。

三级缓存中的迁移说明
1、A创建过程中需要B，于是A将自己放到三级缓存里面，去实例化B
2、B实例化的时候发现需要A。于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A
然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A
3、B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态）
然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并将A自己放到一级缓存里面。

为什么要用三级缓存，用二级缓存可以吗？
没有AOP代理的话，两级缓存就可以解决循环依赖问题，加上AOP，两级缓存是无法解决循环依赖的，因为从三级缓存中获取Bean的工厂对象后，
再调用singletonFactory.getObject()获取Bean的代理对象的时候，每调用一次，就会获取一个新的代理对象，而被代理对象是单例的，这种情况
是不行的，所以要借助二级缓存去解决这个问题，将执行了singletonFactory.getObject()产生的对象放到二级缓存中去，后面去二级缓存中拿，
保证始终只有一个代理对象。另外获取到的是Bean的代理对象，那么注入的也应该是代理对象。




一级可以吗？
是否可以关闭循环依赖？

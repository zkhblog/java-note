# AOP
AOP是一种编程思想。AOP代理是AOP框架创建的对象，代理就是目标对象的增强  

## AspectJ
AspectJ是静态代理，有专门的编译器，在编译期间织入代码  
相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理

## SpringAOP
SpringAOP代理可以使用JDK动态代理，也可以使用CGLIB代理，前者基于接口，后者基于子类

### JDK动态代理
JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。

### CGLIB动态代理
如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类。
注意：CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。

# 异常分类
![img.png](images/异常分类.png)

> rollbackFor 默认对RuntimeException 和Error 以及它们的子类，做回滚

# 事务失效场景
① 访问权限不是```public```，Spring则不会提供事务功能  
② 方法被定义成final、static的，无法通过动态代理，变成事务方法  
③ 方法内部调用
> ① 在Service类中注入自己  
> ② 通过AopContext.currentProxy()获取代理对象

④ 未被Spring管理  
⑤ 多线程调用，不在同一个线程中，获取到的数据库连接不一样，从而是不同的事务  
⑥ 表不支持事务，```myisam```存储引擎不支持事务  
⑦ 自定义了回滚异常。Spring事务，默认情况下，只会回滚RuntimeException（运行时异常）和Error（错误），对于普通的Exception（非运行时异常），
它不会回滚。阿里巴巴开发者规范中，还是要求开发者重新指定该参数，建议一般情况下，将该参数设置成：```Exception```或```Throwable```  
⑧ 嵌套事务回滚多了
```java
// doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况下是直接回滚了整个事务，不只回滚单个保存点
public class UserService {
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private RoleService roleService;

    @Transactional
    public void add(UserModel userModel) throws Exception {
        userMapper.insertUser(userModel);
        roleService.doOtherThing();
    }
}

@Service
public class RoleService {
    @Transactional(propagation = Propagation.NESTED)
    public void doOtherThing() {
        System.out.println("保存role表数据");
    }
}
```
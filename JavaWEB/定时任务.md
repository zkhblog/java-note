# Timer、TimerTask
1 Timer是jdk中提供的一个定时器工具，使用的时候会在主线程之外起一个单独的线程执行指定的计划任务，可以指定执行一次或者反复执行多次  
2 TimerTask是一个实现了Runnable接口的抽象类，代表一个可以被Timer执行的任务
```java
Timer t = new Timer();
t.scheduleAtFixedRate(new TimerTask() {
    @Override
    public void run() {
        System.out.println("hello world");
    }
}, 100, 1000);
```

# Spring的定时任务
1 简单注解方式  
@Scheduled(cron = "")  
cron:按照上一次方法结束时间开始算起，每次都是固定时间点执行  
fixedDelay:按照上一次方法结束时间开始算起，并且间隔给点时间  
fixedRate:从上一次方法执行开始的时间算起，如果上一次方法阻塞住了，下一次也是不会执行，但是在阻塞这段时间内累计应该执行的次数，当不再阻塞时，一下子把这些全部执行掉，而后再按照固定速率继续执行  

```yaml
spring:
  task:
    scheduling: # Spring Task 调度任务的配置，对应 TaskSchedulingProperties 配置类
      thread-name-prefix: my-scheduling- # 线程池的线程名的前缀。默认为 scheduling- ，建议根据自己应用来设置
      pool:
        size: 10 # 线程池大小。默认为 1 ，根据自己应用来设置
      shutdown:
        await-termination: true # 应用关闭时，是否等待定时任务执行完成。默认为 false ，建议设置为 true
        await-termination-period: 60 # 等待任务完成的最大时长，单位为秒。默认为 0 ，根据自己应用来设置
```

2 实现接口方式（动态配置cron）  
implements SchedulingConfigurer

# quartz

# ScheduledThreadPoolExecutor
```java
// 执行周期性或定时任务的线程池
@Bean(name = "scheduledExecutorService")
protected ScheduledExecutorService scheduledExecutorService()
{
    return new ScheduledThreadPoolExecutor(corePoolSize,
            new BasicThreadFactory.Builder().namingPattern("schedule-pool-%d").daemon(true).build(),
            new ThreadPoolExecutor.CallerRunsPolicy())
    {
        @Override
        protected void afterExecute(Runnable r, Throwable t)
        {
            super.afterExecute(r, t);
            Threads.printException(r, t);
        }
    };
}
```

```java
// 产生异步任务的工厂
public class AsyncFactory {
    // 产生记录操作日志这个异步任务
    public static TimerTask recordOperate(final SysOperLog operateLog)
    {
        return new TimerTask()
        {
            @Override
            public void run()
            {
                // 远程查询操作地点
                operLog.setOperLocation(AddressUtils.getRealAddressByIP(operLog.getOperIp()));
                SpringUtils.getBean(ISysOperLogService.class).insertOperlog(operLog);
            }
        };
    }
}
```

```java
/**
 * 异步任务管理器
 * 
 * @author ruoyi
 */
public class AsyncManager
{
    /**
     * 操作延迟10毫秒
     */
    private final int OPERATE_DELAY_TIME = 10;

    /**
     * 异步操作任务调度线程池
     */
    private ScheduledExecutorService executor = SpringUtils.getBean("scheduledExecutorService");

    /**
     * 单例模式
     */
    private AsyncManager(){}

    private static AsyncManager me = new AsyncManager();

    public static AsyncManager me()
    {
        return me;
    }

    /**
     * 执行任务
     * 
     * @param task 任务
     */
    public void execute(TimerTask task)
    {
        executor.schedule(task, OPERATE_DELAY_TIME, TimeUnit.MILLISECONDS);
    }

    /**
     * 停止任务线程池
     */
    public void shutdown()
    {
        Threads.shutdownAndAwaitTermination(executor);
    }
}
```

```java
// 实际使用：保存至数据库
AsyncManager.me().execute(AsyncFactory.recordOper(operLog));
```

SpringBoot环境下：```@Scheduled``` + ```@EnableAsync```

# 、ThreadPoolTaskExecutor

# ThreadPoolTaskScheduler

----------------------------------------------------------
https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247495616&idx=1&sn=e74c733d26351eab22646e44ea74d233&chksm=cf2230e9f855b9ffe1ddb9fe15f72a273d5de02ed91cc97f3066d4162af027299718e2bf748e&token=1260947715&lang=zh_CN&scene=21#wechat_redirect
----------------------------------------------------------


# 单例设计模式
```
https://blog.csdn.net/txwy12/article/details/127906396
```
单例模式的两种创建方式，一种是饿汉式，在静态初始化时就生成单例对象，这样保证了任何线程访问它时都已经被初始化完成，解决了线程安全问题。
访问单例的方法是将构造方法私有化，然后提供一个能获取单例Bean的静态方法，这个Bean就是单例的。
另外一种是懒汉式创建，懒汉式创建就是在对外提供的获取方法里面创建，而不是在静态初始化的时候创建。要保证多线程访问时，不会产生线程安全问题，
可以通过使用双重检索机制来保证在获取Bean的时候创建的对象是唯一的

#　简单工厂模式
定义一个用于创建对象的工厂类

# 工厂方法模式

#　抽象工厂模式

# 策略模式
应用场景：  
使用策略模式优化```if...else```  
```java
// 策略工厂实现类
@Component
public class StrategyUseService implements ApplicationContextAware{
    private Map<FileTypeResolveEnum, IFileStrategy> iFileStrategyMap = new ConcurrentHashMap<>();
    
    // 不同方式解析文件
    public void resolveFile(FileTypeResolveEnum fileTypeResolveEnum, Object objectParam) {
        IFileStrategy iFileStrategy = iFileStrategyMap.get(fileTypeResolveEnum);
        if (iFileStrategy != null) {
            iFileStrategy.resolve(objectParam);
        }
    }

    //把不同策略放到map
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map<String, IFileStrategy> tmepMap = applicationContext.getBeansOfType(IFileStrategy.class);
        tmepMap.values().forEach(strategyService -> iFileStrategyMap.put(strategyService.gainFileType(), strategyService));
    }
}
```

# 模板方法设计模式
① JavaWEB的Servlet中关于doGet/doPost方法的调用  
② jdbcTemplate等

# 代理设计模式
```
https://blog.csdn.net/weixin_43953283/article/details/125783249
```
静态代理的问题是要为每个目标对象都创建一个代理对象，这样代码量很大，也不易维护，所以可以采用动态代理的方式来为任意数量的目标对象创建一个代理对象，
实现的机制就是通过反射的方式去调用目标对象的方法，这样来处理就跟目标对象的类型没有关系了，可以任意代理目标对象。
具体的实现方式可以是jdk的动态代理，也可以是cglib的动态代理

# 装设者设计模式
使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理。  
在AOP中

```
    // 创建一个动态代理类所对应的Class对象
    static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces)
    // 创建一个动态代理对象
    // 参数说明：
    // 类加载器、被代理对象实现的全部接口、实现invocationHandler接口的对象
    static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h)
    
    // invocationHandler接口的实现中
    // 代理类对象，被代理方法，方法调用时所需参数
    public Object invoke(Object proxy,Method method,Object[] params){
        // targetObj才是目标对象
        Object result = method.invoke(targetObj,params);
        return result;
    }
```

# 装饰者设计模式
实现方式：  
①装饰对象和真实对象有相同的接口/抽象类，这样就能以和真实对象相同的交互方式和装饰对象交互；  
②装饰对象包含一个真实对象的引用；  
③装饰对象接收所有请求，然后把这些请求传递给真实对象；  
④装饰对象在传递这些请求以前或以后增加一些附加功能，这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加功能。  
注意：在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。  

# 责任链模式
应用场景：  
一个校验流程，比如参数非空校验、安全校验、黑名单校验、规则拦截等等  

# 观察者模式
观察者和被观察者之间，当被观察者的对象发生变化时，依赖这个对象的观察者就会做出相应逻辑处理。比如spring中的事件监听机制就是观察者模式的实现，
将所有监听器加到多播器中，相应事件产生时，就会通知多播器里面对应的所有监听器，触发监听器的执行


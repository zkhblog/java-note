# 单例设计模式
注意：懒汉式存在线程安全问题，需要特殊处理。  
应用场景：  
① 应用程序的日志应用。因为共享的日志文件一直处于打开状态，只能有一个实例去操作，否则日志内容不好追加。  
② 数据库连接池。  
③ 配置文件读取类。

#　简单工厂模式
定义一个用于创建对象的工厂类

# 工厂方法模式

#　抽象工厂模式

# 模板方法设计模式
① JavaWEB的Servlet中关于doGet/doPost方法的调用  
② jdbcTemplate等

# 动态代理设计模式

# 装设者设计模式
使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理。  
在AOP中

```
    // 创建一个动态代理类所对应的Class对象
    static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces)
    // 创建一个动态代理对象
    // 参数说明：
    // 类加载器、被代理对象实现的全部接口、实现invocationHandler接口的对象
    static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h)
    
    // invocationHandler接口的实现中
    // 代理类对象，被代理方法，方法调用时所需参数
    public Object invoke(Object proxy,Method method,Object[] params){
        // targetObj才是目标对象
        Object result = method.invoke(targetObj,params);
        return result;
    }
```

# 装饰者设计模式
实现方式：  
①装饰对象和真实对象有相同的接口/抽象类，这样就能以和真实对象相同的交互方式和装饰对象交互；  
②装饰对象包含一个真实对象的引用；  
③装饰对象接收所有请求，然后把这些请求传递给真实对象；  
④装饰对象在传递这些请求以前或以后增加一些附加功能，这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加功能。  
注意：在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。  

# 责任链设计模式
可以将请求沿着处理者链进行发送，收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者  
使用场景：  
①


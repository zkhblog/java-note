# HashMap
### 特点
① 在1.7中，HashMap通过数组+链表实现，插入链表节点采用头插法  
② 在1.8中，HashMap通过数组+链表，链表长度等于8时，转化为红黑树，插入链表节点变成了尾差法  
③ 在1.8的hash()中，将hash值高位（前16位）参与到取模运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率  
④ 在1.8的reHash()中，并没有像1.7一样，重新计算每个元素的哈希值，而是通过高位运算来确定元素是否需要移动，使用```e.hash & oldCap```得到
的结果，高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，当结果为1时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 
原数组长度，不必像1.7一样全部重新计算位置  
⑤ 当n的值是2的N次幂的时候，进行&位运算的时候，才可以只看后几位，而不需要全部进行计算

### key的hash值计算
```
// 这样做的目的是让hash值的高位和低位都参与到下面计算数组下标的运算中去
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);    
}
```

### 如何putVal
putVal(int hash, key, value)
① 初始化数组，数组初始容量16，负载因子0.75  
② 计算当前对象的下标，通过 (length -1) & (hash)
```
// 下标计算示意图
// 下标应在0-15范围内；且分布均匀
15(length-1)            0000 1111
&
hash(当前对象的hash值)    0101 0101

i(下标)                  0000 0101
```
③ 如果hash值相等，并且key的引用地址和equals比较都相等，则覆盖原位置数据  
④ 否则如果指定下标位置的元素是TreeNode类型，则进行红黑树的插入操作  
⑤ 否则遍历单链表，如果指定下标位置的元素的next指向null，则将目标元素插入单链表尾部  
⑥ 如果单链表的某个位置元素的hash值和目标hash值相等，并且key的引用地址和equals比较都相等，则覆盖原位置数据  
⑦ 如果遍历单链表的次数等于8，则进行单链表转红黑树的转化  
当数组长度小于64的时候，进行扩容；只有当数组长度大于等于64的时候，才进行转换

### 为什么hashmap扩容的时候是两倍

### 保证其线程安全
① Collections.synchronizedMap集合工具类，通过对原有数据的包装，在进行元素存取时，通过synchronized修饰方法，达到线程安全  
② 使用ConcurrentHashMap。把HashMap拆分成了多个独立的块，这样在高并发的情况下减少了锁冲突的可能，使用的是```NonfairSync```，这个特性
调用CAS指令来确保原子性和互斥性，当多个线程恰好操作到同一个segment上时，那么只会有一个线程得到运行

# ArrayList和LinkedList的区别
① ArrayList基于数组实现，使用索引在数组中查询数据很快，但是删除数据的开销很大，因为需要重排数组中的所有数据；  
② LinkedList插入很快。而且需要更多的内存，LinkedList中的每个节点存储的是实际的数据和前后节点的引用

# 线程安全集合类
① Vector、HashTable，使用synchronized修饰方法保证线程安全  
② ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet


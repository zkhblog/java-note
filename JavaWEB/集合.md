# HashMap
### key的hash值计算
```
// 这样做的目的是让hash值的高位和低位都参与到下面计算数组下标的运算中去
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);    
}
```

### 如何putVal
putVal(int hash, key, value)
① 初始化数组，数组初始容量16，负载因子0.75  
② 计算当前对象的下标，通过 (length -1) & (hash)
```
// 下标计算示意图
// 下标应在0-15范围内；且分布均匀
15(length-1)            0000 1111
&
hash(当前对象的hash值)    0101 0101

i(下标)                  0000 0101
```
③ 如果hash值相等，并且key的引用地址和equals比较都相等，则覆盖原位置数据  
④ 否则如果指定下标位置的元素是TreeNode类型，则进行红黑树的插入操作  
⑤ 否则遍历单链表，如果指定下标位置的元素的next指向null，则将目标元素插入单链表尾部  
⑥ 如果单链表的某个位置元素的hash值和目标hash值相等，并且key的引用地址和equals比较都相等，则覆盖原位置数据  
⑦ 如果遍历单链表的次数等于8，则进行单链表转红黑树的转化  
当数组长度小于64的时候，进行扩容；只有当数组长度大于等于64的时候，才进行转换


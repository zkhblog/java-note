# 为什么用redis作为mysql的缓存
① 具备高性能：将数据缓存在redis中，操作redis缓存就是直接操作内存，所以速度相当快  
② 具备高并发：单机redis的QPS可以突破10w，而mysql很难突破1w，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的

# 使用场景
### String
缓存对象、常规计数、分布式锁、共享session信息等  

### List
消息队列、获取最新列表(```lpush```、```lrange```)等

### Hash
缓存对象

### Set
聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等

### ZSet
排序场景，比如排行榜、电话和姓名排序等

> list  
> ```lpush```来装载用户订阅的文章的id，``` lpush 用户id 文章id 文章id ```，之后要查看某人自己订阅的全部文章，
> 可以用```lrange 用户id 0 10 ```，查看用户订阅的文章 的前10条
> 
> set  
> 在微信抽奖小程序时，如果某用户立即参与抽奖，```sadd key 用户id```，显示已经有多少人参与了抽奖，用```scard key```，抽奖的时候，从set中任意选取N个中奖人，  
> ```srandmember key 2``` 随机抽奖2个人，元素不删除。```spop key 3```随机抽奖3个人，元素会删除。  
> 在朋友圈点赞时，记录新增点赞的功能时，可以用```sadd 发布的消息的id 点赞用户id1 点赞用户id2```  
> 取消点赞时，可以使用```srem 发布的消息的id 点赞用户id```  
> 展现所有点赞过的用户，```smembers 发布的消息的id```，在这里罗列的就是所有点赞过的用户的头像  
> 点赞用户数统计，就是常见的点赞红色数字，```scard 发布的消息的id```  
> 判断某个朋友是否对楼主点赞过，```sismember 用户id 发布的消息的id```  
> 在设计微博好友的社交关系时，共同关注的人可以取集合的交集，```sinter key1 key2```  
> 在推荐好友的时候，可以取差集运算，如```sdiff key1 key2```，此时得到的结果是key1中存在，key2中不存在，因此可以将这个结果推荐给key2，作为可能认识的人。  
> 
> ```zset```  
> 根据商品销售量对商品进行排行显示，定义商品销售排行榜，key为```goods:sellsort```，分数为商品销售数量  
> 商品编号为1001的销量是9，商品编号1002的销量是15，```zadd goods:sellsort 9 1001 15 1002```  
> 有一个客户又买了2件商品1001，商品编号 1001 销量加2，```zincrby goods:sellsort 2 1001```  
> 求商品销量前10名，```zrevrange goods:sellsort 0 10 withscores（从高到低）,zrange（从低到高）```  
> 抖音热搜排行榜，点击视频时，点击量加1，```zincrby hotvcr:20200919 1 八佰```  
> 如果要展示当日排行榜前10条时，可以使用```zrevrange hotvcr:20200919 0 9 withscores```  

# redis单线程模型
Redis单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的。  

### redis单线程快的原因
① Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构  
② Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题  
③ Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制  
④ 高效的数据存储结构：全局hash表以及多种高效数据结构，比如跳表、压缩列表、链表等

### 不使用多线程的原因
① 使用redis，CPU不再是瓶颈，受制于内存和网络  
② 通过使用Pipeline（命令批量）的方式可以提高redis处理速度，达到每秒100万个请求  
③ 单线程的方式，内部维护成本低，因为多线程存在线程切换、加锁/解锁、死锁等问题

### redis6.0之后为什么引入多线程
为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理  

# 持久化
### RDB
将某一时刻的内存数据，以二进制的方式写入磁盘。恢复时是将快照文件移动到安装目录后启动服务器即可，它会读取到内存中。RDB保存的是dump.rdb文件。  

##### 如何实现
redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要
比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。  

Redis 提供了两个命令来生成 RDB 文件，分别是 ```save``` 和 ```bgsave```，他们的区别就在于是否在「主线程」里执行：  
① 执行了 ```save``` 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程  
② 执行了 ```bgsave``` 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞  
③ 执行```flushAll```命令，也会产生dump.rdb文件，但里面是空的，无意义  

```
Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 ```bgsave``` 命令，默认会提供以下配置：  
save 900 1      // 900 秒之内，对数据库进行了至少 1 次修改  
save 300 10     // 300 秒之内，对数据库进行了至少 10 次修改  
save 60 10000   // 60 秒之内，对数据库进行了至少 10000 次修改
```

> fork说明  
> fork的作用是复制一个与当前进程一样的进程，新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。  
> 常用命令  
> ① config set save ""  // 动态停止RDB保存规则  
> ② config get dir      // 获取安装目录

### AOF
Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，
然后逐一执行命令的方式来进行数据恢复。AOF保存的是appendOnly.aof文件。  
先执行命令，再把数据写入日志，这样的好处就是不会把错误的命令写入日志，并且不会阻塞当前写操作命令的执行。但是数据可能会丢失，
因为执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险

##### AOF写日志策略
每修改同步```appendfsync always```，同步持久化，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘，性能较差但数据完整性比较好  
每秒同步```appendfsync everysec```，异步操作，是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘  
不同步```appendfsync no```，不由 Redis 控制写回硬盘的时机，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘

##### AOF重写机制
AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，
只保留可以恢复数据的最小指令集。Redis的重写AOF过程是由后台子进程```bgrewriteaof```来完成的。但是重写过程中，主进程依然可以正常处理命令。
AOF文件持续增大而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），读取当前数据库中的所有键值对，每条记录有一条set语句。
重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。  
redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。

##### AOF恢复异常
先修改appendOnly no为yes，将有数据的aof文件复制一份保存到安装目录，若文件异常，则启动会报错，
需要先用```redis-check-aof --fix```指令进行修复，然后重启redis即可。程序将会对文件修复，扫描aof文件找出第一个出错的命令，
并且删除出错命令之后的所有命令，只保留那些没出错的命令，在大多情况下，被删除的都是aof文件末尾的不完整的命令

### AOF和RDB
RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。适合大规模的数据恢复，对数据完整性和一致性要求不高  
AOF 优点是丢失数据少，但是数据恢复不快，重启速度慢

> ① RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储  
> ② AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。
> redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大  
> ③ 当同时开启两种持久化方式时，在这种情况下，redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下，AOF文件保存的数据集要比RDB文件
> 保存的数据集要完整  
> ④ RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，但是也不要只使用AOF文件，因为RDB更适合用于备份数据库，AOF文件
> 在不断变化不好备份，而且存在潜在的BUG  
> ⑤ 因为RDB文件只用作后备用途，建议只在slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。  
> 如果enable aof，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本简单只load自己的aof文件就可以了。代价是带来了持续的IO，而且
> AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，
> AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值  
> ⑥ 如果不enable aof，仅靠master-slave replication实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果master/slave
> 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个master/slave中的RDB文件，载入较新的那个

> Redis 4.0 提出了混合使用 AOF 日志和内存快照，也叫```混合持久化```，既保证了 Redis 重启速度，又降低数据丢失风险。混合持久化工作在 AOF 日志重写过程，
> 当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，
> 然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式
> 和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。

# Lua脚本
①`EVAL`执行一段lua脚本，每次都需要将完整的lua脚本传递给redis服务器  
②`SCRIPT LOAD`将一段lua脚本缓存到redis中并返回一个tag串，并不会执行  
③`EVAL SHA`执行一个脚本，不过传入参数是②中返回的tag，节省网络带宽  
④`SCRIPT EXISTS`判断②返回的tag串是否存在服务器中  
⑤`SCRIPT FLUSH`清除服务器上的所有缓存的脚本  
⑥`SCRIPT KILL`杀死正在运行的脚本  
⑦`SCRIPT DEBUG`设置调试模式，可设置同步、异步、关闭，同步会阻塞所有请求  

# redis过期删除与内存淘汰
① 如何查看内存大小？在配置文件中的859行 ```maxmemory <bytes>```，注意此处内存大小是bytes字节类型，注意单位转换。  
② 如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。还可以通过```info maxmemory```命令查看redis的内存使用情况  
③ 一般生产上的配置：一般推荐redis设置内存为最大物理内存的四分之三。既可以通过修改配置文件的大小，也可以通过```config set maxmemory``` 内存大小进行设置  
④ redis打满了，会报错：(error) OOM command not allowed when used memory > ```maxmemory```

### 过期删除策略
① 惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。  
③ 定期删除：每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。  
此时依然存在问题：在抽样key时，有key从来没有被抽样到，所以依然大量过期的key堆积在内存中，导致redis内存空间紧张或者很快耗尽。  
所以 Redis 选择「惰性删除+定期删除」这两种策略配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

### 内存淘汰策略
在上述方案执行之后，如果内存达到阈值时，就会触发内存淘汰策略  
生产上，在配置时一般使用```maxmemory-policy allkeys-lru```，命令（```config set maxmemory-policy allkeys-lru```）和修改配置文件都可
> 内存淘汰策略（八种）  
> ```noeviction```：不会淘汰任何key，在新加时会报异常（6.0.8默认）  
>
> 在设置了过期时间的数据中进行淘汰  
> ```volatile-random```：随机淘汰设置了过期时间的任意键值  
> ```volatile-ttl```：优先淘汰更早过期的键值  
> ```volatile-lru```：淘汰所有设置了过期时间的键值中，最久未使用的键值  
> ```volatile-lfu```：淘汰所有设置了过期时间的键值中，最少使用的键值
> 
> 在所有数据范围内进行淘汰  
> ```allkeys-random```：随机淘汰任意键值  
> ```allkeys-lru```：淘汰整个键值中最久未使用的键值（生产上常用）  
> ```allkeys-lfu```：淘汰整个键值中最少使用的键值  

### LRU
LRU 算法的实现是基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，
只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素  
Redis 实现的是一种近似 LRU 算法，目的是为了更好 的节约内存，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，
用于记录此数据的最后一次访问时间。
```
https://www.jb51.net/article/155720.html
```

### LFU
LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，
数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。

# 线程的生命周期
![img.png](images/线程的生命周期.png)

# 线程的同步
### 同步基础
① 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
> 优先使用顺序： Lock  同步代码块（已经进入了方法体，分配了相应资源）  同步方法 （在方法体之外）

### 集合的线程安全
解决list类型线程安全问题  
①vector  
②Collections.synchronizedList(new ArrayList());  
③copyOnWriteArrayList()（JUC提供，常用）

解决set类型线程安全  
①copyOnWriteArraySet()  

解决map类型线程安全  
①concurrentHashMap  

### 锁的分类
①公平锁和非公平锁（synchronized是非公平锁，ReentrantLock可指定）  
②synchronized（隐式可重入锁）、lock（显示可重入锁）  
③验证死锁：```jstack 进程id```

### 死锁的场景
① 表锁不会发生死锁，行锁会发生死锁  
② 读锁、写锁都可能会发生死锁  


# 线程的通信
三种让线程等待和唤醒的机制：  
①使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程。（且这两个方法必须在同步代码块和同步方法中使用）  
notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待。notifyAll ()：唤醒正在排队等待资源的所有线程结束等待  
这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。
因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。  
②使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程。  
③LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程  

### 虚假唤醒
this.await()使当前线程在此处等待，下一次被唤醒的时候继续从此处开始执行，没有再次判断是否等待。所以用while代替if判断可以解决这个问题。  

# 线程池主要的任务处理流程
1、当前线程数小于corePoolSize，则调用addWorker创建核心线程执行任务  
2、如果不小于maxPoolSize，则将任务添加到workQueue队列  
2.1、如果isRunning返回false（状态检查），则remove这个任务，然后执行拒绝策略。  
2.2、线程池处于running状态，但是没有线程，则创建线程  
3、如果放入workQueue失败，则创建非核心线程执行任务，如果这时创建非核心线程失败（当前线程总数不小于maximumPoolSize时），就会执行拒绝策略  
![img.png](images/线程池的执行流程.png)

### 线程池的状态变化
![img.png](images/线程池的状态变化.png)

### 线程的状态变化
![img.png](images/线程的状态变化.png)

### 线程池的execute方法执行
![img.png](images/execute()的执行.png)

### 线程池的坑
① 用```submit```提交任务，不会把异常直接抛出来，可以改为execute方法执行，当然最好就是try...catch捕获  
② Spring内部线程池，其实是SimpleAsyncTaskExecutor，这玩意有点坑，它不会复用线程的  
③ 把拒绝策略设置为DiscardPolicy或DiscardOldestPolicy，Future对象调用get()方法,那么调用线程会一直被阻塞。  
> FutureTask的状态大于COMPLETING才会返回，要不然都会一直阻塞等待。又因为拒绝策略啥没做，没有修改FutureTask的状态，因此FutureTask的状态一直是NEW，所以它不会返回，会一直等待  
> 这个问题，可以使用别的拒绝策略，比如CallerRunsPolicy，它让主线程去执行拒绝的任务，会更新FutureTask状态。如果确实想用DiscardPolicy，则需要重写DiscardPolicy的拒绝策略  
> 使用 Future.get() 时，尽量使用带超时时间的，因为它是阻塞的。

# 线程池参数设置多少合理
```
最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目
```

# 多线程事务

# 线程池的状态变化
![img.png](images/线程池的状态.png)


线程池
为什么线程池的submit不抛出异常

submit中提交的是runnable任务，底层代码会将runnable转换成callable，然后调用call()方法，调用call()方法的时候会用try...catch捕获异常，然后调用setException()方法将异常信息设置给Object，然后要获取异常信息需要调用get()方法

线程池的拒绝策略
①抛弃掉最早的任务
②抛弃掉最新的任务
③抛出异常
④让提交线程去执行当前任务，使异步执行变成同步执行
线程编排
先用CompletableFuture的supplySync方法去封装任务，得到返回的任务的类型也是completableFuture类型的，然后调用completableFuture的allOf()、anyOf()方法编排任务的执行顺序，除了这两个api外，completableFuture也还提供了其他的api，可以用来任意编排任务的执行顺序，也还可以处理返回结果，捕获异常等都是completableFuture提供的api能操作的
线程锁
① 使用synchronized实现代码块加锁，加的锁对于所有线程来说必须是同一把锁才能保证线程安全性，比如用当前对象作为锁，因为当前对象是单例的，所以所有线程都使用的是同一把锁
② 使用synchronized实现同步方法，普通方法其实可以理解成代码块加当前对象锁，而静态方法可以理解成代码块把类对象作为锁
③第三个就是使用Java代码加锁，比如使用lock接口的实现类加锁，一般常用的是ReentrantLock。在加锁前调用锁的lock()方法进行加锁，解锁的时候是在finally方法中调用unlock方法进行解锁。
④synchronized和ReentrantLock的区别
实现上不同，一个是通过Java代码加锁，一个是JVM层面加锁
在出现异常时，synchronized加锁后，会由JVM自动将加的锁释放掉，不会因为出现了异常没有释放锁造成线程死锁。而用lock加的锁必须在finally中解锁，否则就可能会出现死锁情况
lock能实现准确的唤醒通过机制，而synchronized只能实现唤醒一个或者唤醒全部。
比如用lock调用newCondition()方法后得到一个condition实例，然后线程通过这个condition实例进行阻塞，再别的线程调用这个condition实例的singal()方法就能唤醒这个线程。
一个对象调用wait()方法就会阻塞当前线程，并释放锁，其他线程在调用同样对象的notify()方法时就会将被阻塞的线程唤醒，但是唤醒的线程是随机的。
虚假唤醒
在唤醒线程的时候，唤醒了多余的线程，主要是因为在执行线程阻塞的时候，使用了if判断，这样的话，当不满足条件时，就没有阻塞当前线程，而是跳过if判断执行后面的代码了，相当于被唤醒了。因此可以通过使用while循环来解决if判断的问题，同时虚假唤醒的问题也就被解决了



# volatile
保证了以下两个特性：  
① 可见性：写时，会把共享变量副本立即刷新回主内存中，读时，线程私有工作内存的数据失效，重新回主内存中读取最新共享变量  
② 有序性：不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止指令重排  
③ 不保证原子性：volatile变量不适合参与到依赖当前值的运算，比如i++操作等

### volatile实现原理
1 内存屏障  
JVM在把字节码生成机器码的时候，发现操作的是volatile变量的话，会按照JMM的规范，在相应位置插入内存屏障  
所谓的内存屏障是一种指令屏障，使得CPU或编译器对屏障指令的 前和后进行重排序，也叫内存栅栏或栅栏指令

2 读屏障  
在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据（共享变量副本）失效，重新回到主内存中获取最新数据
> 插入内存屏障策略一：在每个volatile读操作的后面插入一个LoadLoad屏障，可以禁止处理器把上面的volatile读与下面的普通读重排序；  
插入内存屏障策略二：在每个volatile读操作的后面插入一个LoadStore屏障，可以禁止处理器把上面的volatile与下面的普通写重排序

3 写屏障  
在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中
> 插入内存屏障策略三：在volatile写操作的前面插入一个StoreStore屏障，可以保证volatile写之前，前面的所有普通读写操作都已经刷新到主内存中  
插入内存屏障策略四：在volatile写操作的后面插入一个StoreLoad屏障，可以避免volatile写与后面的volatile读写进行重排序

> 内存屏障指令总结：  
> ① volatile写之前的操作，都禁止重排序到volatile之后  
> ② volatile读之后的操作，都禁止重排序到volatile之前  
> ③ volatile写之后volatile读，禁止指令重排序




# 管程
JVM中的同步是基于进入和退出监视器对象（Monitor、锁、管程对象）来实现的，每个对象实例都会有一个Monitor对象，并且Monitor对象和Java对象一同创建并销毁，它的底层是由C++语言实现的。

# FutureTask
get()获取结果，如果没有计算完成容易导致程序阻塞。通常的做法是以轮询的方式去获取结果，尽量不要阻塞（通过isDone()判断是否完成，未完成sleep，之后再次判断）  
结论：Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果

# CompletableFuture
优点：  
1 异步任务结束时，会自动回调某个对象的方法  
2 主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行  
3 异步任务出错时，会自动回调某个对象的方法

```
// 获得结果
get()
get(long timeout,TimeUnit unit)
join()
getNow(T valueIfAbsent)

// 主动触发计算
complete(T valueIfAbsent)

// 对计算结果进行处理
thenApply()：当前步出错，不走下一步
handle()：当前步错，可以带着错误走下一步

// 对计算结果进行消费
thenAccept：接收任务的处理结果，并消费处理，无返回结果

// 对计算速度进行选用
applyA.applyToEither(applyB,...)

// 对计算结果进行合并
thenCombine
```

总结：  
①没有传入自定义线程池，都用默认线程池ForkJoinPool  
②传入自定义线程池  
如果执行第一个任务时，传入了一个自定义线程池，调用thenRun方法执行第二个任务时，则第二个任务和第一个任务共用同一个线程池  
如果执行第一个任务时，传入了一个自定义线程池，调用thenRunAsync执行第二个任务时，则第一个任务使用的是自定义线程池，第二个任务使用的是ForkJoinPool  
③第一个任务处理太快，按照系统优化切换原则，会直接使用main线程处理

# 锁
① 高并发时，同步调用应该去考量锁的性能损耗，能用无所结构，就不要用锁；能用锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁  
② 对于普通同步方法，锁的是当前实例对象本身；对于静态同步方法，锁的是当前类的Class对象；对于同步方法块，锁的是synchronized括号内的对象  
③ 如果锁的是当前对象this，被锁定后，其他线程都不能进入到当前对象的其他synchronized方法，类对象锁也是如此，但是这两者不冲突  
④ ACC_STATIC,ACC_SYNCHRONIZED访问标志被用来区分该方法是否是静态同步方法  
⑤ 调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor锁，然后再执行方法，最后方法完成时（无论时正常完成还是非正常完成）释放锁

## 悲观锁
synchronized关键字和Lock的实现类都是悲观锁。适合写操作多的场景，先加锁可以保证写操作时数据正确

## 乐观锁
通过使用无锁编程实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升  
实现：  
1 版本号机制Version  
2 最常采用的是CAS算法，Java原子类的递增操作就是通过CAS自旋实现的

# 可重入锁
1 每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针  
2 当执行```monitorenter```时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将计数器加1  
3 在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁  
4 当执行```monitorexit```时，Java虚拟机则需将锁对象的计数器减1，计数器为零代表锁已被释放

# 线程中断机制
| 方法名称 | 说明|
| ---- | ---- |
| public void interrupt() | 实例方法interrupt()仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程 |
| public boolean isInterrupted() | 通过检查中断标志位，判断当前线程是否被中断 |
| public void boolean interrupted() | 静态方法：Thread.interrupted()；判断线程是否被中断并清除当前中断状态（返回当前线程的中断状态，并将当前线程的中断状态清零并重新设为false） |

当对一个线程调用interrupt()时：  
1 如果线程处于正常活动状态，那么将该线程的中断标志设置为true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以，interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行  
2 如果线程处于被阻塞状态（例如处于sleep、wait、join等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出阻塞状态，并抛出一个InterruptedException异常

中断只是一种协商机制，修改中断标识位仅此而已，不是立刻stop打断

# 线程等待唤醒机制
1 使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程，**两个方法都要在同步代码中执行**  
2 使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程，**在lock()，unlock()对里面才能正确调用condition中线程等待和唤醒的方法**  
3 LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程

# CAS
执行CAS操作的时候，将**内存位置的值（实际值）**与**预期值**进行比较，如果匹配，那么处理器将会自动将该位置的值更新为**新值**。如果不匹配，那么处理器不做任何操作。
注意，多个线程同时执行CAS操作只有一个会成功，其他线程在重试的这种行为称为**自旋**

### CAS缺点
1 如果CAS失败，会一直进行尝试，一直不成功的话会给CPU带来很大的开销  
2 通过增加版本号解决存在的ABA问题。具体应用就是可以用```AutomicStampedReference```代替```AutomicInteger```解决ABA问题。

# 原子类

# AQS
1、LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。  
2、LockSupport中的```park()```和```unpark()```的作用分别是阻塞线程和解除阻塞线程。

AQS使用一个volatile修饰的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，
通过CAS完成对State值的修改。通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的控制效果。

> Node类：  
SHARED：表示线程以共享的模式等待锁。EXCLUSIVE：表示线程正在以独占的方式等待锁。  
> waitStatus：当前节点在队列中的状态  
0：当一个Node被初始化的时候的默认值  
CANCELLED：为1，表示线程获取锁的请求已经取消了  
CONDITION：为-2，表示节点在等待队列中，节点线程等待唤醒  
PROPAGATE：为-3，当前线程处在SHARED情况下，该字段才会使用  
> thread：表示处于该节点的线程  
prev：前驱指针  
predecessor：返回前驱节点，没有的话抛出npe  
nextWaiter：指向下一个处于condition状态的节点  
next：后继指针

### 非公平锁和公平锁
对比公平锁和非公平锁的tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少了一个判断```!hasQueuedPredecessors()```  
该方法中判断了是否需要排队，导致公平锁和非公平锁的差异如下：  
公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；  
非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占用锁对象，也就是说队列的第一个排队线程在```unpark()```之后还是需要竞争锁（存在线程竞争的情况下）
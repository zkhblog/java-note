# 一 MySQL Query Optimizer
1、MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供
他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为最优的，这部分最耗费时间）  
2、当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，
MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询
条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。

# 二 Explain
使用explain关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。即能分析你的查询语句或结构的性能瓶颈。
## 2.1 能干嘛？
表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用、每张表有多少行被优化器查询
## 2.2 各字段解释
①id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序  
②select_type：查询的类型，主要用于区别普通查询、联合查询、子查询等复杂查询  
③table：显示这一行的数据是关于哪张表的  
④type：显示查询使用了何种类型；从最好到最差依次是：system>const>eq_ref>ref>range>index>All  
⑤possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及的字段上若存在索引，则该索引将被列出，但不一定
被查询实际使用。  
⑥key：实际使用的索引。如果为null则没有使用索引。查询中若使用了覆盖索引，则索引和查询的select字段重叠。  
⑦key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好，  
key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。  
⑧red：显示索引哪一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值。  
⑨rows：根据表统计信息及索引选用情况，大致估算出找到所需记录所需要读取的行数。  
⑩Extra：  
Using fileSort：  
MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了前者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，
可能排序是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这里可能是ordery by，group by语句的结果，
这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。  
Using temporary：用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。  
Using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行。如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，
表明索引用来读取数据而非执行查找动作。  
Using where：表明使用了where过滤  
Using join buffer：使用了连接缓存  
impossible where：where子句的值总是false，不能用来获取任何元组；  
select tables optimized away、distinct（出现少）
## 2.3 type详解（显示查询使用了何种类型）
①system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计；  
②const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量；  
③eq_ref：唯一性索引，对于每个索引建，表中只有一条记录与之匹配，常见于主键或唯一索引扫描；  
④ref：非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体；  
⑤range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围索引扫描比全表扫描好，因为他只需要开始索引
的某一点，而结束另一点，不用扫描全部索引。
⑥index：与All区别为index类型只遍历索引树。这通常比All快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但是index是从索引中读取的，而all是从硬盘中读的）  
⑦all：将遍历全表以找到匹配的行


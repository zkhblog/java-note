------------------------------------
1 JUC并发编程第40集objectMonitor的运行流程


------------------------------------
# JNI

# 管程
JVM中的同步是基于进入和退出监视器对象（Monitor、锁、管程对象）来实现的，每个对象实例都会有一个Monitor对象，并且Monitor对象和Java对象一同创建并销毁，它的底层是由C++语言实现的。

# FutureTask
get()获取结果，如果没有计算完成容易导致程序阻塞。通常的做法是以轮询的方式去获取结果，尽量不要阻塞（通过isDone()判断是否完成，未完成sleep，之后再次判断）  
结论：Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果

# CompletableFuture
优点：  
1 异步任务结束时，会自动回调某个对象的方法  
2 主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行  
3 异步任务出错时，会自动回调某个对象的方法

```
// 获得结果
get()
get(long timeout,TimeUnit unit)
join()
getNow(T valueIfAbsent)

// 主动触发计算
complete(T valueIfAbsent)

// 对计算结果进行处理
thenApply()：当前步出错，不走下一步
handle()：当前步错，可以带着错误走下一步

// 对计算结果进行消费
thenAccept：接收任务的处理结果，并消费处理，无返回结果

// 对计算速度进行选用
applyA.applyToEither(applyB,...)

// 对计算结果进行合并
thenCombine
```

总结：  
①没有传入自定义线程池，都用默认线程池ForkJoinPool  
②传入自定义线程池  
如果执行第一个任务时，传入了一个自定义线程池，调用thenRun方法执行第二个任务时，则第二个任务和第一个任务共用同一个线程池  
如果执行第一个任务时，传入了一个自定义线程池，调用thenRunAsync执行第二个任务时，则第一个任务使用的是自定义线程池，第二个任务使用的是ForkJoinPool  
③第一个任务处理太快，按照系统优化切换原则，会直接使用main线程处理  

# 锁
## 悲观锁
synchronized关键字和Lock的实现类都是悲观锁。适合写操作多的场景，先加锁可以保证写操作时数据正确  

## 乐观锁
通过使用无锁编程实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升  
实现：  
1 版本号机制Version  
2 最常采用的是CAS算法，Java原子类的递增操作就是通过CAS自旋实现的  

## 锁的是什么
① 高并发时，同步调用应该去考量锁的性能损耗，能用无所结构，就不要用锁；能用锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁  
② 对于普通同步方法，锁的是当前实例对象本身；对于静态同步方法，锁的是当前类的Class对象；对于同步方法块，锁的是synchronized括号内的对象  
③ 如果锁的是当前对象this，被锁定后，其他线程都不能进入到当前对象的其他synchronized方法，类对象锁也是如此，但是这两者不冲突  
④ ACC_STATIC,ACC_SYNCHRONIZED访问标志被用来区分该方法是否是静态同步方法  
⑤ 调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor锁，然后再执行方法，最后方法完成时（无论时正常完成还是非正常完成）释放锁  

# 可重入锁
1 每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针  
2 当执行```monitorenter```时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将计数器加1  
3 在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁  
4 当执行```monitorexit```时，Java虚拟机则需将锁对象的计数器减1，计数器为零代表锁已被释放

# 线程中断机制
| 方法名称 | 说明|
| ---- | ---- |
| public void interrupt() | 实例方法interrupt()仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程 |
| public boolean isInterrupted() | 通过检查中断标志位，判断当前线程是否被中断 |
| public void boolean interrupted() | 静态方法：Thread.interrupted()；判断线程是否被中断并清除当前中断状态（返回当前线程的中断状态，并将当前线程的中断状态清零并重新设为false） |

当对一个线程调用interrupt()时：  
1 如果线程处于正常活动状态，那么将该线程的中断标志设置为true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以，interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行  
2 如果线程处于被阻塞状态（例如处于sleep、wait、join等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出阻塞状态，并抛出一个InterruptedException异常  

中断只是一种协商机制，修改中断标识位仅此而已，不是立刻stop打断  

# 线程等待唤醒机制
1 使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程，**两个方法都要在同步代码中执行**  
2 使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程，**在lock()，unlock()对里面才能正确调用condition中线程等待和唤醒的方法**  
3 LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程



# fork/join分支合并池

# AQS
1、LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。  
2、LockSupport中的```park()```和```unpark()```的作用分别是阻塞线程和解除阻塞线程。  

AQS使用一个volatile修饰的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，
通过CAS完成对State值的修改。通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的控制效果。

> Node类：  
SHARED：表示线程以共享的模式等待锁。EXCLUSIVE：表示线程正在以独占的方式等待锁。  
> waitStatus：当前节点在队列中的状态  
0：当一个Node被初始化的时候的默认值  
CANCELLED：为1，表示线程获取锁的请求已经取消了  
CONDITION：为-2，表示节点在等待队列中，节点线程等待唤醒  
PROPAGATE：为-3，当前线程处在SHARED情况下，该字段才会使用  
> thread：表示处于该节点的线程  
prev：前驱指针  
predecessor：返回前驱节点，没有的话抛出npe  
nextWaiter：指向下一个处于condition状态的节点  
next：后继指针  

### 非公平锁和公平锁
对比公平锁和非公平锁的tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少了一个判断```!hasQueuedPredecessors()```  
该方法中判断了是否需要排队，导致公平锁和非公平锁的差异如下：  
公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；  
非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占用锁对象，也就是说队列的第一个排队线程在```unpark()```之后还是需要竞争锁（存在线程竞争的情况下）  






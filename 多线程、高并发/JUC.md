------------------------------------



------------------------------------

# fork/join分支合并池

# AQS
1、LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。  
2、LockSupport中的```park()```和```unpark()```的作用分别是阻塞线程和解除阻塞线程。  

AQS使用一个volatile修饰的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，
通过CAS完成对State值的修改。通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的控制效果。

> Node类：  
SHARED：表示线程以共享的模式等待锁。EXCLUSIVE：表示线程正在以独占的方式等待锁。  
> waitStatus：当前节点在队列中的状态  
0：当一个Node被初始化的时候的默认值  
CANCELLED：为1，表示线程获取锁的请求已经取消了  
CONDITION：为-2，表示节点在等待队列中，节点线程等待唤醒  
PROPAGATE：为-3，当前线程处在SHARED情况下，该字段才会使用  
> thread：表示处于该节点的线程  
prev：前驱指针  
predecessor：返回前驱节点，没有的话抛出npe  
nextWaiter：指向下一个处于condition状态的节点  
next：后继指针  

### 非公平锁和公平锁
对比公平锁和非公平锁的tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少了一个判断```!hasQueuedPredecessors()```  
该方法中判断了是否需要排队，导致公平锁和非公平锁的差异如下：  
公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；  
非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占用锁对象，也就是说队列的第一个排队线程在```unpark()```之后还是需要竞争锁（存在线程竞争的情况下）  






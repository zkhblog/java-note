使用RabbitMq实现延迟队列的好处？
可以保证消息不丢失，以及未被正确处理的消息不会被丢弃（采用死信队列保证消息至少被消费一次）

1、堆积在信道里的消息的总数会存在比预取值大1的情况。即最后一条消息被ack了，rabbitmq感知到了又往
该信道里发了一条消息，而被ack的消息还没来得及删除之前，这个时候就是比预取值大1的时候。

2、发消息注意事项：
①要求队列和队列中的消息都必须持久化
②在消息被发送到队列，还没来得及持久化到磁盘上时，MQ宕机，消息也会丢失
所以发消息可以采用发布确认模式使消息发送一定不丢失
开启发布确认：channel.confirmSelect();
单个确认：同步等待确认，吞吐量非常有限。
批量确认：当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。
异步批量确认：最合适的解决方案。

3、交换机类型
发布、订阅模式的交换机类型是fanout
路由模式的交换机的类型是direct
主题模式的交换机的类型是topic
①当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像fanout了
②如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是direct了

4、死信队列
产生来源：消息过期、队列达到最大长度、消息被拒
①消息不能被消费时，放入死信队列，等待后续处理
②死信队列存在一定的延迟性，因此可以作为延迟消息来处理，例如用户下单后长时间未支付自动关闭订单
③消息过期时间的设置
第一处是在普通队列设置转发死信交换机时可以设置消息过期时间
第二处是在生产方发送消息时设置过期时间（用的多）

问题：
①如何处理异步发布未确认消息？
②写主题模式下发布消息、消费消息的过程

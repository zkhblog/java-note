# JVM本地锁解决并发问题（不推荐）
1、多例模式下锁失效  
2、事务隔离级别设置成读未提交可以解决锁失效问题，但是一般不设置成读未提交，而读已提交和可重复读都可能会引起锁失效  
3、集群部署环境下

# Mysql解决并发问题
1 使用一条SQL语句完成查询判断及数量更新
```sql
update db_stock set count = count -1 where product_code = '1001' and count >= 1;
```
存在问题：  
① 锁的范围问题，可能会导致行级锁变成表级锁  
> MySQL悲观锁中想要使用行级锁，必须得给查询条件或者更新条件的字段上加索引，加了索引后也不能让其失效，否则会给全表加锁

② 同一个商品有多条库存记录时，比如北京和上海仓库都有库存，存在这样两条记录的情况下，没法根据业务对库存量进行扣减，这不是一条SQL语句能办到的，必须在业务代码中判断  
③ 无法记录库存变化前后的状态  

2 悲观锁  
```sql
select ... for update;
```
悲观锁能解决同一个商品有多条记录时，可以再通过程序控制选择一条记录进行扣减，并记录库存扣减前后状态变化。因为通过for update已经锁定了相应行记录，不用担心其他事务的修改，其他事务的修改会被阻塞  
存在问题：  
① 性能问题  
② 死锁问题：对加锁的顺序要保持一致  
③ 库存操作要统一  

3 乐观锁  
① 高并发情况下，可能由于重试判断，导致性能变低  
② 存在ABA问题  
③ 读写分离情况下，导致乐观锁不可靠，因为从机读取数据的版本总是有延迟，不是新version，导致主机更新一直失败  

### MySQL锁总结
性能：一个sql > 悲观锁 > jvm锁 > 乐观锁  
如果追求极致性能，业务场景简单并且不需要记录数据前后变化的情况下，优先选择一个sql  

如果写并发量较低（多读），争抢不是很激烈的情况下，优先选择乐观锁  

如果写并发量较高，一般会经常冲突，此时如果选择乐观锁的话，会导致业务代码不间断的重试，所以优先选择mysql悲观锁  

不推荐jvm本地锁

# Redis解决并发问题
### 乐观锁
watch：可以监控一个或者多个key的值，如果在事务执行之前，key的值发生变化，则取消事务执行  
multi：开启事务  
exec：执行事务  

存在问题：  
性能变低很多，而且有可能因为连接不够用导致锁失效

# 分布式锁
### 基于redis命令实现分布式锁
① 一是客户端程序异常未解锁导致死锁，为防死锁给锁增加过期时间，二是要锁独占，因此用如下命令：```set key value ex 20 nx```  
② 加锁不成功时，再次获得锁用while循环的方式，不要用递归调用，递归调用导致多个栈帧入栈等待，最后库存扣减量等于栈帧的数量，而不是减1  
③ 设置uuid值防误删，通过```lua脚本```保证判断和删除是原子的  
```
// 一定要用两个参数的构造器，一个参数的构造器很可能会报错
redisTemplate.execute(new DefaultRedisScript<>(script, Integer.class),Arrays.asList("lock"),uuid);
```
④ 不可重入导致死锁问题  

```
// 用Lua脚本实现非公平的可重入锁的加锁过程
if redis.call('exists',KEYS[1]) == 0 or redis.call('hexists',KEYS[1],ARG[1]) == 1
then
    redis.call('hincrby',KEYS[1],ARG[1],1)
    redis.call('expire',KEYS[1],ARG[2])
    return 1
else
    return 0
end

// 用Lua脚本实现非公平的可重入锁的解锁过程
if redis.call('hexists',KEYS[1],ARGV[1]) == 0
then
    return nil
elseif redis.call('hincrby',KEYS[1],ARGV[1], -1) == 0
then
    return redis.call('del',KEYS[1])
else
    return 0
end
```

⑤ 自动续期  
Timer定时器 + Lua脚本
```
if redis.call('hexists',KEYS[1],ARGV[1]) == 1
then
    return redis.call('expire',KEYS[1],ARGV[2])
else
    return 0
end
```

### 用redis命令实现分布式锁总结
加锁：  
1 set k v ex 30 nx  
2 用hash结构和Lua脚本实现可重入锁  
    2.1 判断锁是否被占用，如果没有被占用则直接获取锁（```hset/hincrby（field为0时也可以增加）```），并设置过期时间（expire）  
    2.2 如果锁被占用，则判断是否是当前线程占用锁（```hexists```），如果是则重入（```hincrby```），并设置过期时间  
    2.3 否则在代码中通过重试再次获取锁
3 Timer定时器 + lua脚本实现锁的自动续期  

解锁：  
1 用lua脚本实现先判断value再删除，这样能保证原子性和防误删  
2 hash结构 + lua脚本实现可重入解锁  
    2.1 判断当前线程的锁是否存在，不存在则返回null，将来抛出异常  
    2.2 存在则直接减1（```hincrby -1```），判断减1后的值是否为0，为0则释放锁（```del```），并返回1，代表释放锁成功  
    2.3 不为0，表示释放了一层锁，还不到解锁的时候，则返回0

自动续期：

redis集群状态下存在问题：  
1 客户端A从master获取到锁  
2 在master将锁同步到slave

### redisson分布式锁
```
@Bean
public RedissonClient redissonClient(){
    Config config = new Config();
    config.useSingleServer().setAddress("redis://ip:port");
    return Redisson.create(config);
}
```
① 可重入锁RLock对象
```
RLock lock = this.redissonClient.getLock("xxx");
lock.lock()/unlock();
```
② 公平锁
基于排序队列实现
```
RLock lock = this.redissonClient.getFairLock("xxx");
lock.lock()/unlock();
```
③ 联锁和红锁  
联锁不推荐使用，需要所有redis节点获取锁成功，才能获取锁成功  
红锁半数以上节点获取锁成功，可以研究一下红锁算法  
④ 读写锁
```
RReadWriteLock rwLock = this.redissonClient.getReadWriteLock("xxx");
rwLock.readLock().lock()/unlock();
rwLock.writeLock().lock()/unlock();
```
⑤ 信号量
```
RSemaphore semaphore = this.redissonClient.getSemaphore("xxx");
semaphore.trySetPermits(3);
semaphore.acquire()/release();
```
⑥ 闭锁
```
RCountDownLatch cdl = this.redissonClient.getCountDownLatch("xxx");
cdl.trySetCount(6);
cdl.await()/countDowntch();
```

### 基于Mysql关系型数据库实现分布式锁
原理是用到了唯一键索引的特征  

思路：  
① 加锁：```insert into tb_lock(lock_name) values ('lock');```执行成功代表加锁成功  
② 释放锁：获取锁成功的请求执行业务操作，执行完成之后通过delete删除对应记录  
③ 重试获取锁：递归  

实现要点：  
① 独占排他互斥的特性：基于唯一建索引  
② 防死锁：客户端程序获取到锁之后，客户端程序宕机。  
        可以通过给记录加一个获取锁的时间列，然后通过```另外的服务```的定时任务检查获取锁的时间和当前系统时间的差值是否超过了阈值，超过则删除，即过期自动释放了锁  
③ 防误删：借助于id的唯一性防止误删锁  
④ 原子性：  
        写数据本身会开启事务，即可保证原子性。  
        为了防止锁重入问题，会存在多个sql语句同时执行需要保证原子性的问题，此时可以借助于mysql的悲观锁来实现  
⑤ 可重入性：  
        通过记录服务器信息、线程信息以及重入次数来保证可重入性  
⑥ 自动续期：```服务器内的定时任务```重置获取锁的系统时间  
⑦ 单机故障：搭建MySQL主备  
⑧ 集群情况下锁机制失效问题（主数据库写完数据后宕机，还没来得及同步数据，此时从数据库是没有把锁信息同步过来的，其他线程连接从库，能够重新获得锁）  
...

### 分布式锁总结
① 简易程序：mysql > redis(lua脚本) > zk  
② 性能：redis > zk > mysql  
③ 可靠性：zk > redis = mysql  
最佳实践：  
追求性能的应用可以用redis  
追求可靠性的应用可以用zk  
简单实现，对性能、可靠性要求都不高的情况下，可以选择用msql实现分布式锁
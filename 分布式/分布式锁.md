# JVM本地锁解决并发问题（不推荐）
1、多例模式下锁失效  
2、事务隔离级别设置成读未提交可以解决锁失效问题，但是一般不设置成读未提交，而读已提交和可重复读都可能会引起锁失效  
3、集群部署环境下

# Mysql解决并发问题
1 使用一条SQL语句完成查询判断及数量更新
```sql
update db_stock set count = count -1 where product_code = '1001' and count >= 1;
```
存在问题：  
① 锁的范围问题，可能会导致行级锁变成表级锁  
> MySQL悲观锁中想要使用行级锁，必须得给查询条件或者更新条件的字段上加索引，加了索引后也不能让其失效，否则会给全表加锁

② 同一个商品有多条库存记录时，比如北京和上海仓库都有库存，存在这样两条记录的情况下，没法根据业务对库存量进行扣减，这不是一条SQL语句能办到的，必须在业务代码中判断  
③ 无法记录库存变化前后的状态  

2 悲观锁  
```sql
select ... for update;
```
悲观锁能解决同一个商品有多条记录时，可以再通过程序控制选择一条记录进行扣减，并记录库存扣减前后状态变化。因为通过for update已经锁定了相应行记录，不用担心其他事务的修改，其他事务的修改会被阻塞  
存在问题：  
① 性能问题  
② 死锁问题：对加锁的顺序要保持一致  
③ 库存操作要统一  

3 乐观锁  
① 高并发情况下，可能由于重试判断，导致性能变低  
② 存在ABA问题  
③ 读写分离情况下，导致乐观锁不可靠，因为从机读取数据的版本总是有延迟，不是新version，导致主机更新一直失败  

### MySQL锁总结
性能：一个sql > 悲观锁 > jvm锁 > 乐观锁  
如果追求极致性能，业务场景简单并且不需要记录数据前后变化的情况下，优先选择一个sql  

如果写并发量较低（多读），争抢不是很激烈的情况下，优先选择乐观锁  

如果写并发量较高，一般会经常冲突，此时如果选择乐观锁的话，会导致业务代码不间断的重试，所以优先选择mysql悲观锁  

不推荐jvm本地锁

# Redis解决并发问题
### 乐观锁
watch：可以监控一个或者多个key的值，如果在事务执行之前，key的值发生变化，则取消事务执行  
multi：开启事务  
exec：执行事务  

存在问题：  
性能变低很多，而且有可能因为连接不够用导致锁失效

# 分布式锁
### 基于redis实现分布式锁
① 一是客户端程序异常未解锁导致死锁，为防死锁给锁增加过期时间，二是要锁独占，因此用如下命令：```set key value ex 20 nx```  
② 加锁不成功时，再次获得锁用while循环的方式，不要用递归调用，递归调用导致多个栈帧入栈等待，最后库存扣减量等于栈帧的数量，而不是减1  
③ 设置uuid值防误删，通过```lua脚本```保证判断和删除是原子的  
```
// 一定要用两个参数的构造器，一个参数的构造器很可能会报错
redisTemplate.execute(new DefaultRedisScript<>(script, Integer.class),Arrays.asList("lock"),uuid);
```
④ 不可重入导致死锁问题  

```
// 用Lua脚本实现非公平的可重入锁的加锁过程
if redis.call('exists',KEYS[1]) == 0 or redis.call('hexists',KEYS[1],ARG[1]) == 1
then
    redis.call('hincrby',KEYS[1],ARG[1],1)
    redis.call('expire',KEYS[1],ARG[2])
    return 1
else
    return 0
end

// 用Lua脚本实现非公平的可重入锁的解锁过程
if redis.call('hexists',KEYS[1],ARGV[1]) == 0
then
    return nil
elseif redis.call('hincrby',KEYS[1],ARGV[1], -1) == 0
then
    return redis.call('del',KEYS[1])
else
    return 0
end
```

⑤ 自动续期  
Timer定时器 + Lua脚本
```
if redis.call('hexists',KEYS[1],ARGV[1]) == 1
then
    return redis.call('expire',KEYS[1],ARGV[2])
else
    return 0
end
```

### 手写分布式锁总结
加锁：  
1 set k v ex 30 nx  
2 用hash结构和Lua脚本实现可重入锁  
    2.1 判断锁是否被占用，如果没有被占用则直接获取锁（```hset/hincrby（field为0时也可以增加）```），并设置过期时间（expire）  
    2.2 如果锁被占用，则判断是否是当前线程占用锁（```hexists```），如果是则重入（```hincrby```），并设置过期时间  
    2.3 否则在代码中通过重试再次获取锁
3 Timer定时器 + lua脚本实现锁的自动续期  

解锁：  
1 用lua脚本实现先判断value再删除，这样能保证原子性和防误删  
2 hash结构 + lua脚本实现可重入解锁  
    2.1 判断当前线程的锁是否存在，不存在则返回null，将来抛出异常  
    2.2 存在则直接减1（```hincrby -1```），判断减1后的值是否为0，为0则释放锁（```del```），并返回1，代表释放锁成功  
    2.3 不为0，表示释放了一层锁，还不到解锁的时候，则返回0

自动续期：

redis集群状态下存在问题：  
1 客户端A从master获取到锁  
2 在master将锁同步到slave
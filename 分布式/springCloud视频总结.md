一、注册中心

Eureka包含两个组件：EurekaServer和EurekaClient
EurekaServer提供服务注册服务：各个微服务节点通过配置后，会在EurekaServer中进行注册，
这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。
EurekaClient通过注册中心进行访问
这是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的、使用轮询负载算法的负载均衡器。
在应用启动后，将会向EurekaServer发送心跳（默认周期30秒）。如果EurekaServer在多个心跳周期内没有接收到某个节点的心跳，
EurekaServer将会从服务注册列表中把这个服务节点移除（默认90秒）

Eureka的自我保护机制：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。暂时保留没有心跳的
微服务的信息，期待着它的恢复。
从设计上来说，是因为Eureka满足CAP理论的AP分支，也就是不保证强一致性，（那么有这样的机制就可以实现容错的目的---猜测）。
出厂默认，自我保护机制是开启的，使用eureka.server.enable-self-preservation=false可以禁用自我保护模式

Eureka集群原理说明：
1、先启动Eureka注册中心
2、启动服务提供者payment支付服务
3、支付服务启动后会把自身信息（比如服务地址以别名方式注册进Eureka）
4、消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址
5、消费者获得调用地址后，底层实际是利用HttpClient技术实现远程调用
6、消费者获得服务地址后会缓存在本地jvm内存中，默认每间隔30秒更新一次服务调用地址

只要服务注册中心不是Eureka，就不使用@EurekaServer和@EurekaClient，
代替的是@EnableDiscoveryClient，该注解用于向使用consul和zookeeper作为注册中心时注册服务

三种注册中心的区别主要体现在设计上，即CAP理论的取向，Eureka是AP的实现，Zookeeper和Consul是CP的实现
因此，Eureka有搭建集群的必要性，微服务在Zookeeper上创建的是临时节点，微服务下线，临时节点**立即**被删除，
真实的网络设计上，一般首选AP，要满足网站的高可用特性，为了保证可用性，系统B可以返回旧值，保证系统的可用性。

二、负载均衡

Ribbon是客户端的负载均衡工具，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，配合restTemplate实现客户端的远程调用
Ribbon集成于消费方进程，消费方通过它来获取到服务提供方的地址，然后再从这些地址中获取到一个合适的服务器
与Ribbon不同的是nginx是服务器端负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求，即负载均衡是由服务端实现的

Ribbon在工作时分成两步
第一步选择EurekaServer，它优先选择在同一个区域内负载较少的Server
第二步再根据用户指定的策略，在从Server获取到的服务注册列表中选择一个地址。
其中，Ribbon提供了多种策略，比如轮询、随机和根据响应时间加权
Ribbon默认自带的负载规则：都是实现了IRule接口的实现类，根据特定算法从服务列表中选取一个要访问的服务，
Ribbon自带七种：
RoundRibbonRule：轮询
RandomRule：随机
RetryRule：先按照RoundRibbonRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试
WeightedResponseTimeRule：响应速度越快的实例选择权重越大，越容易被选择
BestAvailableRule：会过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务
AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例
ZoneAvoidanceRule：默认规则，复合判断server所在区域的性能和server的可用性选择服务器

替换负载均衡的步骤：
1）在容器中new出一个IRule接口的实现类
2）在启动类上加@RibbonClient(name="服务提供方id",configuration=MySelfRule.class)

负载均衡算法（轮询）的原理是rest接口的请求数%服务器集群总数量=实际调用服务器位置下标，每次服务重启后rest接口计数从1开始
当总请求数为1时，1%2=1
	2	2%2=0
.......
List<ServiceIntance> intances=discoveryClient.getInstances("服务id名");
根据上面取模的规则得到每次执行任务的实例的下标，然后调用list.get(index)得到这台实例的相关信息


三、远程调用

# 远程调用的流程
1 @RequestBody将对象转换为json  
2 找到指定服务，给指定接口发送请求  
3 将json放到请求体里，发送请求  
4 对方服务收到请求后，解析请求体里面的json数据  
5 将请求体中的json数据转换为对方服务的参数类型（注意：只需要两边的字段名称和参数类型一致即可）

在远程调用时，使用的是restTemplate.postForObject(Url url,Object request,Class<T> responseType)
而在服务提供方，方法的参数上不能缺少@RequestBody

前面在使用Ribbon+RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。
但是实际情况是往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。
在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面
标注一个Feign注解即可），即可完成对服务提供方的接口绑定，简化了使用Ribbon时，自动封装服务调用客户端的工作量。

Feign接口和@FeignClient(value="服务名")注解实现远程调用，在主启动类上要开启Feign的远程调用@EnableFeignClients，
Feign自带负载均衡配置项，它内部集成的有Ribbon

OpenFeign超时控制：
openFeign默认等待1秒钟，超过后报错
解决办法：设置Feign客户端超时时间（openFeign默认支持Ribbon），因此配置方式如下：
ribbon:
     #指的是建立连接所用的时间，适用于网络正常的情况下，两端连接所用的时间
     ReadTimeOut： 5000
     #指的是建立连接后从服务器读取到可用资源的时间
     ConnectTimeout: 5000

四、服务降级
什么是服务雪崩？（一种故障现象）
当多个微服务之间调用时，在这个扇出的链路上某个微服务的响应时间过长或者服务不可用，就会导致整个系统
崩溃，形成所谓的“雪崩效应”。在这样的情况下，发现一个模块的某个实例失败后，这个有问题的模块还调用了其他的模块，
这样就会发生级联故障。

Hystrix的三个重要概念？
1、服务降级
	对方系统不可用了，需要给出一个终极解决办法，向调用方返回一个符合预期的、可处理的备选响应（fallback），而不是长时间的等待
或者抛出调用方无法处理的异常。
发生的情况：程序运行异常、超时、服务熔断出发服务降级、线程池/信号量打满也会导致服务降级
处理办法：
服务提供方设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作为服务降级fallback，
在服务提供方的超时方法上
标注@HystrixCommand，此注解内写明超时后的处理方法，又能写明超时时长，然后在主启动类上标注@EnableCircuitBreaker启用注解 
在配置超时后处理方法时可以使用@DefaultProperties(defaultFallback="")统一全局的异常处理方法
上面的处理办法是在服务提供方作的服务降级处理，除此之外，还可以在客户端做服务降级处理，在客户端做服务降级处理的办法：
实现@FeignClient标注的接口，在实现类里写服务降级的处理逻辑，这样做的话，即使服务提供方挂了，也不影响服务消费方给出友好提示信息

2、服务熔断
	类比保险丝达到最大服务访问后，直接拒绝访问，然后调用服务降级的方法并返回友好提示
熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而
熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。
熔断类型：熔断打开、熔断关闭、熔断半开
断路器的三个重要参数：
	快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒
	请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认为20，也就是在10秒内，调用次数不足20次，即使
所有请求都超时或其他原因失败，断路器都不会打开。
	错误百分比阈值：当请求总数在快照时间窗内超过了阈值，在默认设定50%阈值情况下，这时候就会讲断路器打开。
断路器开启的条件：默认10秒内超过20个请求，并且请求内50%以上的都失败，到达以上阈值，断路器将会开启
当开启的时候，所有的请求都不会进行转发
一段时间后（默认是5秒），这个时候断路器时半开状态，会让其中一个请求进行转发，失败继续开启，成功则断路器关闭
断路器打开之后，再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback，通过断路器，
实现了自动发现错误并讲降级逻辑切换为主逻辑，减少响应延迟的效果。
主逻辑的恢复靠Hystrix实现的自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，
在这个时间窗内，降级逻辑是临时的
主逻辑，当休眠时间窗到，断路器进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器会闭合，主逻辑恢复，
如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。

3、服务限流
	秒杀高并发等操作，严禁拥挤，有序进行

五、网关路由
三大核心概念：

路由是构建网关的基本模块，由ID、URI、一系列的断言和过滤器组成，如果断言为true则匹配该路由
断言：如果请求与断言相匹配则进行路由
过滤：指的是Spring框架中的GateWayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改

gateway的核心逻辑是路由转发和执行过滤器链
默认情况下GateWay会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能


六、springcloud alibaba
nacos：
为什么nacos支持负载均衡？jar包内集成了ribbon，所有可以使用restTemplate实现远程调用，
注意结合restTemplate和Ribbon实现负载均衡时在@Bean处
要加@LoadBalanced注解，即远程调用时有多个实例，选择哪个实例要指定负载均衡算法，默认轮询

各注册中心的对比？
Eureka支持AP，而Zookeeper和Consul支持CP
强大的Nacos支持AP或CP，即可切换



Sentinel采用的懒加载机制，需要执行一次访问，这个熔断框架才监控微服务，相比Hystrix不同的是，
Sentinel的优势在于不需要大量的环境搭建的工作， 

流控规则基本属性讲解：
资源名：唯一名称，默认请求路径
针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）
阈值类型：QPS：当调用该api的QPS达到阈值的时候，进行限流
	线程数：当调用该api的线程数达到阈值的时候，进行限流
是否集群：不需要集群


⭐流控模式
①直接——>快速失败（系统默认），api达到限流条件时，进行限流，报错后直接调用默认的错误信息
②关联，当关联的资源达到阈值时，就限流自己，大批量线程高并发访问B，导致A失效了
③链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）

⭐流控效果：
①快速失败：直接失败，抛异常
②预热：根据冷加载因子(默认值为3)，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值
应用场景：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进来，
慢慢的把阈值增长到设置的阈值
③排队等候：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效

Sentinel的降级策略
①平均响应时间：当1s内持续进入5个请求时，并且对应时刻的平均响应时间均超过阈值，那么在接下来的时间窗口之内，对这个方法的调用
都会自动的熔断。注意Sentinel默认的统计上限是4900ms。
②异常比例：当资源的每秒请求量>=5，并且每秒异常总数占通过量的比值超过阈值之后，资源进入降级状态，即在接下来的时间窗口之内，对
这个方法的调用都会自动的返回。异常比率的阈值范围是[0.0,1.0]，代表0%~100%
③异常数：当资源近1分钟的异常数目超过阈值之后进行熔断。注意由于统计时间窗口是分钟级别的，若timeWindow小于60s，则结束熔断状态
后仍可能再进入熔断状态。

























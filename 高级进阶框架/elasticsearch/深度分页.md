```
https://blog.csdn.net/qq_36558538/article/details/103256397

from/size、scroll、search_after三者的比较
from / size : 该查询的实现原理类似于mysql中的limit，比如查询第10001条数据，那么需要将前面的10000条都拿出来，进行过滤，最终才得到数据。(性能较差，实现简单，适用于少量数据，数据量不超过1w，1w是可配置的，量力而行)。
scroll：该查询实现类似于消息消费的机制，首次查询的时候会在内存中保存一个历史快照以及游标(scroll_id)，记录当前消息查询的终止位置，下次查询的时候将基于游标进行消费(性能良好，维护成本高，在游标失效前，不会更新数据，不够灵活，一旦游标创建size就不可改变，适用于大量数据导出或者索引重建)
search_after: 性能优秀，类似于优化后的分页查询，历史条件过滤掉数据，不适合存在跳跃查询的场景。
```